[{"title":"数学可视化(09)——Rayarch光线步进算法","date":"2023-11-14T00:55:30.000Z","url":"/2023/11/14/Mathematical-Visualization-09/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 图形学中的几何对象表现方式 3D几何对象的表示有显式和隐式两种方式 显式 隐式 多边形面片 数学函数公式 点云 距离场函数 NURBS CSG(Constructive Solid Geometry) 体素 分形函数 隐式方式不能提供直观的视觉呈现，但在计算几何体相交、碰撞等方面更方便 通常用显式的方式去构建复杂场景的几何体，用隐式的方式去构建一些加速结构和简化几何体，用来处理优化算法 将用距离场函数及几何体的运算来构建3D几何对象 在二维屏幕上，即使使用隐式3D几何构造方式，提供了几何数据，输入数据也只有uv两个维度 绘制三维几何体，至少需要三个变量来描述，这时需要一个场景深度来辅助处理，也就是知道uv后，再获取该像素点在场景下的深度值 这就需要光线步进算法来协助完成了 光线步进算法 先讨论渲染体、相机、屏幕uv，3个基本的对象 通过屏幕坐标uv和相机的位置，可以得到多条以相机为起点，朝向场景发射的射线 针对每条射线，可以定义该射线的光线步进算法，伪代码： 我们需要预先定义一些关于光线的预定义数据,包括光线最大的步进步数、总共行进的最大距离长度、光线与物体表面距离的最小长度等 完成后可以得到当前屏幕场景所有深度值 "},{"title":"数学可视化(08)——分形Fractal","date":"2023-11-07T01:17:59.000Z","url":"/2023/11/07/Mathematical-Visualization-08/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 分形Fractal的概念和定义 分形Fractal最早是由数学家曼德波罗在《统计自相似性和分数维度》的论文中提出的 与随机、噪声等混沌状态不同，分形具有递归性定义 分形是以非整数维形式填充空间、对空间占有的特定形式 具有自相似性 分形维数与拓扑维数 拓扑维数:通过空间中的一个点需要几个变量定义来确定 如:地球表面一个点，只需要经度纬度就可定义，因此地球表面实际的拓扑维数是二维 分形维数:在拓扑维数下定义的一个图形，把它拆成更小的形状，需要几个更小的形状才能拼回原来的图形 分形维数公式:D=logN / logE，其中N为拼回原图形需要的小图形的个数，E为原图形被缩小为原来的几分之一的倒数 分形维数与原图形填充是可以有直观上的对比映射的 如:分形维数在1~2区间时，越接近1，图形越向一维线段的填充；越接近2时，越像二维图形的填充；而越接近3时，越接近三维几何体填充 实时渲染用的分形 最常用的是分形布朗运动(Fractual Brownian Motion，fbm) 简称fbm，是布朗运动的拓展 通过将不同频率和振幅的噪声函数进行叠加操作 布朗运动:布朗运动是一种随机运动，粒子的运动方向随时改变，其运动轨迹是一条处处连续但处处不可微的曲线，是一种无规分形曲线，也具有统计性质的自相似性 一般fbm公式为每级噪声函数，其振幅缩减为上一级的1/2，频率增加为上一级的一倍，并通过参数控制fbm由几级噪声函数叠加而成。这里的噪声函数可以是任意噪声函数 公式: fbm = noise(uv) + 0.5 * noise(2*uv)+ 0.25 * noise(4*uv)… fbm变种: 湍流（Turbulence )，在fbm中对噪声函数取绝对值，使噪声值在0时发生突变，产生湍流纹理，fbm = |noise(uv)| + 0.5 *|noise(2*uv)| + 0.25*|noise ( 4*uv)|… 翘曲域(Domain Wrapping)，翘曲域噪声用来模拟卷曲、螺旋状纹理，如烟雾、大理石等，f(p) = fbm( p + fbm( p + fbm( p ))) 通过调整算法和噪声函数，可以组合出各种各样的分形噪声效果 因此fbm常被用作生成程序化纹理中 "},{"title":"数学可视化(07)——随机与噪声","date":"2023-11-07T00:11:56.000Z","url":"/2023/11/07/Mathematical-Visualization-07/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 计算机中的随机数 通过算法生成的随机数一般都是伪随机数 除非我们每次通过不同的随机种子获取 由于shader中标量和向量的元素通常都在0-1区间，因此生成0-1的float值是非常必要的 frac：返回指定值的小数部分，返回大于0小于1的值 frac函数就是将值映射到0-1区间，可以将sin函数从[-1, 1]映射到[0, 1] 将这个函数拓展到二维 数字都是随机写的，主要看效果图够不够随机和混沌 还可以替换成rgb3个通道的二维随机 可以利用floor或cell函数来处理整数索引，使得某块或某段数据获得的随机值是一样的，这样可以做一些tile级别的随机 再利用frac函数处理每一个tile内的uv坐标 可以修改绘制函数 噪声 白噪声(White Noise)：是值较宽频率范围内，各等宽的频带所含噪声功率谱密度相等的噪声。也就是前面所用的随机值或哈希值产生的噪声，就属于白噪声 值噪声(Value Noise)：是由tile四个角上的点的随机值插值生成的噪声图，不过值噪声图只由简单的线性插值生成的话会出现晶格化的现象。前面以tile随机生成的噪声图就是值噪声图 梯度噪声(Gradient Noise)：所以会用一些梯度函数进行插值，其中经典的有Perlin噪声、Simplex噪声 网格噪声(Cellular Noise)：在程序化生成纹理时更为常用，它是基于距离场的，对于每个像素计算它到最近的特征点的距离，一般来说需要遍历所有四个特征点，计算它们到当前像素点的距离，并把最近的距离保存下来，也就是利用距离场生成了一个Voronoi图 "},{"title":"数学可视化(06)——平移、旋转、缩放变换","date":"2023-11-06T23:39:40.000Z","url":"/2023/11/07/Mathematical-Visualization-06/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 变换的基础概念 矢量、标量的概念 矢量点乘、叉乘、加减乘除运算 矢量单位化、正交化、长度的计算 矩阵与矢量、矩阵与矩阵的运算、单位矩阵、逆矩阵等 空间中物体位置的矩阵表示 2D空间中用三维矩阵表示 3D空间中用四维矩阵表示 平移矩阵 旋转矩阵 3D下旋转轴有3个，对应3个矩阵 缩放矩阵 注意变换矩阵左乘的顺序，不满足交换律 "},{"title":"数学可视化(05)——2D距离场与图像","date":"2023-11-06T05:22:47.000Z","url":"/2023/11/06/Mathematical-Visualization-05/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 有向距离场Signed Distance Field (SDF) 2D距离场是由原点到平面上任意一点的距离，定义为矢量，是有方向的。由这些有方向距离定义的空间，为有向距离场 可以利用距离的正负来定义图形的边界，这样就可以利用距离场来绘制图形了 2D距离场所需参数 原点O 目标点P 距离（可以是不同定义下的距离） 欧式距离 切比雪夫距离 曼哈顿距离 其他距离定义… 2D距离场 圆形：sdCircle(float2 pos, float d) 正方形：sdSquare(float2 pos, float d) 正菱形：sdRhombic(float2 pos, float d) 椭圆形：sdEllipse(float2 pos, float w, float h) 矩形：sdRect(float2 pos, float w, float h) 菱形：sdRhombus(float pos, float w, float h) 梯形：sdTrapezoid(float2 pos, float up, float down, float h) 等腰三角形：sdTriangleIsocaeles(float2 pos, float down, float h) 任意多边形：sdAnything(float2 pos, float2[] points) 极坐标下任意正多边形：sdPolygopn(float2 pos, float r)  SDF的值是可以进行数学运算的，包括加、减、min、max、与或非等 SDF操作还可以加圆角 还可以制作圆环效果 "},{"title":"数学可视化(04)——极坐标系与函数拟合","date":"2023-11-05T10:38:58.000Z","url":"/2023/11/05/Mathematical-Visualization-04/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 极坐标系 定义M点离极点的距离为极径ρ，向量M与极轴夹角为Θ 可以容易得到M点在两个坐标系下的相互转化公式： 函数拟合 数学是自然的语言，是对客观世界规律的描述（数学建模） 如何图像形状我们都可以用数学的函数集合（函数空间）来表示。而空间完备性就是函数空间是否可以逼近任意函数 闭区间上的连续函数可以用多项式基数一致逼近（泰勒级数） 闭区间上的周期函数可以用三角函数一致逼近（傅立叶级数） 函数拟合其实就是寻找映射、变换、组合的函数过程 函数拟合的步骤 到哪里找？确定某个函数空间 找哪个？度量哪个函数是好的或更好的 怎么找？求解或优化 图形学中的函数拟合的方法 直接法：采样点，最小二乘法寻找最小平方误差的函数，求解待定系数（连续函数） 间接法：多段区间函数拼接（可以是非连续函数的集合） 心型函数 "},{"title":"数学可视化(03)——函数可视化","date":"2023-11-05T09:46:27.000Z","url":"/2023/11/05/Mathematical-Visualization-03/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 绘制坐标轴的前半段代码，相当于绘制y = 0的函数，相当于abs(function = 0) "},{"title":"数学可视化(02)——ShaderLab内部常用函数","date":"2023-11-04T09:54:00.000Z","url":"/2023/11/04/Mathematical-Visualization-02/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; floor、ceil与frac 常用于数据分段 floor(x)：返回小于或等于指定值x的最大整数值(向下取整) ceil(x)：返回大于或等于指定值x的最小整数值(向上取整) frac(x)：返回指定值的小数部分，返回大于0小于1值 fmod(x,y)：返回指定值x/y的浮点余数，这种方法对于非整数取模更灵活，但比使用floor/ceil + frac方式开销更大一些 modf(x,out ip)：将指定值x拆分为小数部分和整数部分，其中返回值为小数部分，参数输出为整数部分，每个部分的符号与x相同，与fmod相比它更适合处理整数和取模的方式。效率高的同时同样不如fmod用起来灵活 saturate、clamp、step、sign 常用于数据值处理（数据截断） saturate(x)：将指定值固定在0-1的范围内 clamp(x,min,max)：将指定值固定到指定的最大最小值范围 step(y,x)：比较两个值，前者小于后者则返回0，否则返回1。可用于二元判断 sign(x)：返回指定值的符号，x小于0返回-1；x等于0返回0；x大于0返回1。可用于三元判断 lerp与smoothstep lerp(x,y,s)：执行两个指定值的线性插值，s为插值系数 smoothstep(min,max,x)：如果x在[min,max]范围内，则返回介于0和1之间的平滑埃尔米特插值 过渡部分是由外到内由白到黑的过渡部分 如果用白色去减就可以变成由黑到白的过渡了 "},{"title":"数学可视化(01)——坐标转换与距离","date":"2023-11-04T03:19:20.000Z","url":"/2023/11/04/Mathematical-Visualization-01/","tags":[["数学可视化","/tags/%E6%95%B0%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 本质 本质是构造一个造型函数（Sharping Function） 输入是一个二维的向量坐标XY，输出是一个三维向量RGB 在CPUSample中，输入的是分辨率下的像素索引i,j 在GPUSample中，输入的是屏幕坐标u,v 也就是说，我们默认屏幕处于正交笛卡尔坐标系的第四象限，即平面直角坐标系下的第四象限 造型函数：c.rgb = uv.xxx; c.rgb = uv.yyy; c.rgb = half3(uv.x, 0, uv.y); 第四象限改为第一象限，只需将uv的y方向颠倒即可 uv.y = 1.0 - uv.y; 这样uv的y方向就与Unity默认的y方向就一致了 如果想显示整个四个象限，将原点从(0,0)移动到屏幕中心 具体做法是：uv = uv * 2.0 - 1.0; 这样将[0,1]的区间变成[-1,1]的区间 图形渲染中常用的距离的类型 以下都以四象限为例： uv = uv * 2.0 - 1.0; 欧式距离 c = sqrt((pow(uv.y, 2) + pow(uv.x, 2)) * 0.5); * 0.5 是为了不出现&gt;1.0的白色的截断的值，使颜色过渡更平滑 曼哈顿距离 x、y轴轴距绝对值的总和 如上图，绿色的线代表欧式距离，其他线是两点间等效的曼哈顿距离 c = (abs(uv.y) + abs(uv.x)) * 0.5; 切比雪夫距离 也叫做棋盘距离 c = max(abs(uv.y), abs(uv.x)); 马氏距离 是一种特殊的欧氏距离，要考虑不同量度特性间的联系 要考虑不同维度间，数据的协方差来计算距离 要将量度转换到同一维度下，再计算欧氏距离 屏幕的宽度高度属于不同维度，如果不统一量度，会造成图形的拉伸 为了图形不被拉伸，需要将宽高转换到同一量度上 half co = h / w;c = sqrt((pow(uv.y * co, 2) + pow(uv.x, 2)) * 0.5); "},{"title":"Unity C#反射与特性","date":"2023-07-26T03:39:54.000Z","url":"/2023/07/26/unity-ClassRef-2/","tags":[["unity","/tags/unity/"],["C#","/tags/C/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 知识点一、回顾 编译器是一种翻译程序，它用于将源语言程序翻译为目标语言程序 源语言程序 : 某种程序设计语言写成的，比如C#、C、C++、Java等语言写的程序 目标语言程序 : 二进制数表示的伪机器代码写的程序 说人话 : 我们写的如C#语言，计算机是不认识的，只是我们自己看得懂自己定的一些规则 所以需要编译器把这些C#等语言翻译成二进制，计算机能够认识的规则 二、程序集 程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物 在Windows系统中，它一般表现为后缀为.dll(库文件)或者是.exe(可执行文件)的格式 说人话 : 程序集就是我们写的一个代码集合，我们现在写的所有代码 最终都会被编译器翻译为一个程序集供别人使用 比如一个代码库文件(dll)或者一个可执行文件(exe) 三、元数据 元数据就是用来描述数据的数据 这个概念不仅仅用于程序上，在别的领域也有元数据 说人话 : 程序中的类，类中的函数、变量等等信息，就是程序的元数据 有关程序以及类型的数据被称为元数据，它们保存在程序集中 四、反射的概念 程序正在运行时，可以查看其他程序集或者自身的元数据 一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射 说人话 : 在程序运行时，通过反射可以得到其他程序集或者自己程序集代码的各种信息 类、函数、变量、对象等等，实例化它们、执行它们、操作它们 五、反射的作用 因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性 1.程序运行时得到所有元数据，包括元数据的特性 2.程序运行时，实例化对象，操作对象 3.程序运行时创建新对象，用这些对象执行任务 六、语法相关 Type、Assembly、Activator Type 创建一个测试类 Type(类的信息类) 它是反射功能的基础 它是访问元数据的主要方式 使用Type的成员获取有关类型声明的信息 有关类型的成员(如构造函数、方法、字段、属性和类的事件等) 获取Type 1.万物之父object中的GetType()可以获取对象的Type 2.通过typeof关键字，传入类名，也可以获取对象的Type 3.通过类的名字，也可以获取类型 注意 : 类名必须包含命名空间，不然找不到 type、type2、type3指向的内存地址一样，即一个类的元数据只有一份 Assembly(程序集类) 可以通过Type得到类型所在程序集信息 获取类中的所有公共成员 首先得到Type 然后得到所有公共成员 需要引用命名空间 using System.Reflection; 获取类的公共构造函数并调用 1.获取所有构造函数 2.获取其中一个构造函数，并执行 得到构造函数，要传入Type数组，数组中内容按顺序是参数类型 执行构造函数，要传入object数组，表示按顺序传入的参数 2-1得到无参构造 2-2得到有参构造 获取类的公共成员变量 1.得到所有成员变量 2.得到指定名称的公共成员变量 3.通过反射获取和设置对象的值 3-1通过反射，获取对象的某个变量的值 3-2通过反射，设置指定对象的某个变量的值 获取类的公共成员方法 通过Type类中的GetMethod方法，得到类中的方法 MethodInfo是方法的反射信息 1.如果存在方法重载，用Type数组表示参数类型 2.调用该方法 注意 : 如果是静态方法，Invoke中的第一个参数传null即可 其他 Type : 得枚举 GetEnumName GetEnumNames 得事件 GetEvent GetEvents 得接口 GetInterface GetInterfaces 得属性 GetProperty GetPropertys 等等 反射关键类Assembly和Activator（未完待续）"},{"title":"UnityUI-IMGUI","date":"2023-07-25T02:44:38.000Z","url":"/2023/07/25/UnityUI-IMGUI/","tags":[["unity","/tags/unity/"],["unityUI","/tags/unityUI/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 一、 工作原理和主要作用 二、文本和按钮控件 三、多选框和单选框 四、输入框和拖动条(滑动条slider) 五、图片绘制和框 六、工具栏和选择网格 七、滚动列表和分组 八、窗口 九、自定义皮肤样式 十、自动布局 IMGUI学习结束！"},{"title":"class","date":"2023-07-16T02:44:03.000Z","url":"/2023/07/16/jx/","categories":[["undefined",""]],"content":" "},{"title":"DOTS(5) 核心包学习 Jobs(1)","date":"2023-07-09T02:16:31.000Z","url":"/2023/07/09/dots-05/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Unity Jobs System 包含C# Jobs System和C++ Jobs System 利用多核计算平台来简单安全的编写与执行多线程代码 既可以与ECS结合使用也可以单独使用 编写代码时不需要关心运行平台CPU核心情况与线程资源的情况 Job System的调度 Jobs System是通过创建Job任务，而不是线程，来管理多线程代码的 Unity引擎内部会跨多个核心来管理一组工作线程，以避免上下文的切换 执行时，Jobs System会将我们创建的Job任务放到Job队列中，以等待执行 工作线程会从Job队列中获取并执行相应的工作 C# Jobs System 一般不会出现手写多线程程序中出现的Race Conditions问题 因为在每个Job任务中，只访问数据的拷贝 或者是转换一段buffer的所有权给这个Job(Native Container) C# Jobs System实际上使用的就是Unity引擎内C++ Jobs System的代码 所以在引擎与游戏线程之间没有上下文切换的开销 但毕竟C#与C++下的内存管理与值的类型定义不同，所以在写C# Jobs System代码时，需要区别哪些是Blittable Type类型的数据，哪些类型不是 Blittable Types VS Non-Blittable Types Blittable Types : 在托管代码和非托管代码的内存中具有相同的表示形式 值得注意的是，C#中的布尔值占用4个字节，C++中占1个字节 NativeContainers 在写Job程序时，除使用Blittable Type类型数据外，还可以用C++上非托管内存堆数据，不过需要依赖另外一个DOTS核心包——Collection中的NativeContainer，以及Unity引擎下为特殊用途，特殊定制的一些容器类型，如 : Unity引擎内定义的数组 : NativeArray NativeArray的子集 : NativeSlice 用于映射访问GameObject，Transform对象的TransformAccess以及TransformAccessArray Unity Collections Package 可变大小的NativeArray : NativeList 单键值对映射表 : NativeHashMap 单键多值的 : NativeMultiHashMap 先进先出的队列 : NativeQueue 支持多线程同时写入的各种数据容器等 可自定义的NativeContainers 这些数据容器都是非托管堆上分配的 有DisposeSentinel安全检查来避免内存泄露错误 有AtomicSafetyHandle来追踪所有权与访问权限，避免Race Condition错误 这些类型容器都需要用完手动调用dispose接口进行释放 没有引用返回，会在C#7中支持 Allocation Types 这些类型容器在创建时还会涉及分配类型的选择 一般最常用的有三种 : Persistent : 对应对象的长生命周期内存 TempJob : 对应在Job中存在的短生命周期内存，4帧以上会收到警告 Temp : 对应在一个函数内使用的更短生命周期内存 这些分配类型在Unity引擎内部分别对应不同的allocator类型 "},{"title":"DOTS(4) 核心包环境安装与工具概览","date":"2023-07-01T05:50:45.000Z","url":"/2023/07/01/dots-04/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 2022.2.8b以上的编辑器版本 在Windows-Package Manager中选择Add package by name…输入com.unity.entities包名，等待安装完成 安装完后，会发现编辑器的Preferences属性列表中多了Entities标签和Jobs标签 Project Settings中新增了DOTS和Burst AOT Setting标签 编辑器的菜单中会多出一个Jobs菜单项 在Component菜单下也会看到DOTS的子菜单，里面的选项是将GameObject对象转化成Entity，不过这是DOTS暂时保存的旧接口，DOTS1.0中已不推荐使用 Windows菜单下会多出一个Entities标签，下面是Entities的一些工具窗口 在Inspector窗口右上角会出现一个小圆点，有纯灰色、纯橙色、灰底橙心三种形态，分别代表处于Authoring、Runtime、Mix三种模式下的哪种数据模式 Unity Profiler中还会增加Entities Memory、Entities Structural Change两个模块，分别用来记录DOTS下Entities相关内存分配和使用情况，以及显示运行时发生Entities Structural Change的事件 核心包学习路径图"},{"title":"DOTS(3) Cache层级结构与排队管理","date":"2023-06-20T23:50:15.000Z","url":"/2023/06/21/dots-03/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 如何理解L1、L2、L3级缓存的这种树形结构设计 CPU指令执行也是在排队，很多算法也都是在处理数据队列 现实中各种队列的内外因素不同，我们可以通过一些设计、规则、以及调度的调整，去改善队列的效率 计算机上也一样，dots面向数据的设计部分，就是在设计队列的结构，ECS就是在组织队列中的规则，Job System就是在做队列的调度 队列类型 单队列 这样的队列比较简单，参与队伍管理的工作人员也可以很少 但队列中的任何一个人或业务人员出现了处理时间较长的问题，造成的阻塞会是整个系统级别的 这时，很容易就能想到用多条队列并行处理不就解决了吗 多队列 当初的计算机与CPU设计人员也是这么想的，并行计算、多核设计也是这么干的 但多行队列的占地会比较大，需要的服务人员与并行队列数量成正比 换到CPU上，就需要有更好的工艺，给多核留更大的空间 即使这样，单纯的多队列也并不一定能够高效，原因是木桶能装多少水要看最短的短板，我们不知道系统中每个人需要花费多久时间完成，当一个并行队列中，一个人花费时间太长时，也会造成整体的系统依旧很慢 这时处理并行，调度串行的队列就派上用场了 3.单队列+调度 这种队列需要一个如图中黄色的调度人员来管理队列，当某人窗口被阻塞时，调度人员会将长队列等待的人调到其他处理窗口中 长的单行队列，就很像队列的Catch缓存 与多行并行队列相比，这种队列更适合队伍中每个人员处理时间长度不一致，以及新到队列中的人到来时间随机的情况，这种情况下单行调度队列比纯并行队列更有效 4.复合队列 就是单行调度队列加上多行并行队列的组合，如现实中的做核酸队列 这种队列比较适合多阶段批次处理事务的队列，每个批次内每个人处理的时间近似的情况 这种复合队列中的并行队列，有点catch line的概念了 不过一旦出现每个人处理时间有巨大差异时，队列效率就会变得很差了，调度员的调度工作与复杂度也会上升 这时我们的队列可以做进一步演化 可以再增加一层并行队列，并增加两个调度人员，一个是应付进入整体队列系统的调度人员C，用来调度随机到来的人员进入类似属性的队列；另外一个调度员B则按照每个并行队列中，单个队列是否达到上限，将队列中的人统一调度到下一层的单行队列中进行等待 增加处理完队列后的后续工作，虽然队列按相同的属性组织完成了，但离开队列系统的情况是离散的，导致离开后队列变乱了，进而导致后续的系统效率又变差了 那么我们考虑在进入第一次并行队列时，按属性组分离队列的话，类比到CPU上，就是把数据组织成矢量，做对齐优化，处理时又可以兼容SIMD指令处理，这样一个指令处理多条类似数据，不仅加快了处理效率，还可以保持离开队列系统时数据的连续 最后，做一个更大胆的类比 可以将蓝色部分类比成L1级缓存，青色部分类比成L2级缓存，紫色部分理解为一个CPU的逻辑盒，红色部分就是逻辑盒共享的L3级缓存了 而每个不同级别的缓存内的队列，可以类比成catch line,或者Archetype Chunk的概念 而整个队列系统组织数据Layout的过程，可以理解成ECS 黄色调度员类比成不同调度方式下的Job System 进入到蓝色处理员处理的人员队列，类比成Burst编译器优化过后的，支持SIMD的代码指令 总之，Catch为什么会设计成这样的层级结构，是由不同核、不同计算单元的不同情况下，不同数据与指令的调度需求决定的 类比不能代表真实情况，只是帮助理解 一般来说，不同的队列结构设计依赖单通道、多通道与单阶段、多阶段两个维度，在现实生活中都能找到类似的实例 : 队列模型建模考虑的因素 : 到达分布 到达规模 队列中人员耐心程度 有限/无限队长 队列结构…… "},{"title":"unity反射底层原理","date":"2023-06-19T01:56:37.000Z","url":"/2023/06/19/unity-ClassRef/","tags":[["unity","/tags/unity/"],["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; C#对象的内存布局 类 : 是一种类型描述，描述了这个类型有哪些数据组成，同时描述一些成员函数 类的实例 : new 类(); 是具体的内存对象，就是一块内存，包含这个类里的数据，这块内存是所有数据成员的集合 类的成员函数会到哪里去 类的成员函数属于代码指令，编译完成后，会变成代码指令，全局只有一份，所有的类的实例公用一份这个代码指令 存入到代码段 : 编译器把代码编译成.exe的可执行文件，在运行这个文件时，会把里面的所有代码加载到内存的代码段，再跳到main函数里一行一行执行 this实例的概念 成员函数里面，如果我们使用this，指的就是当前的对象实例 例 : 调用这个成员函数.test()的时候，我们会自动给成员函数，把当前的对象实例作为this传入进去 this.age操作的就是当前的对象实例这块内存 底层就会把t这个实例(这块内存)传递给this(this指向这块内存),通过this来操作 类的实例 类的数据成员的所有数据(看得见的，age，4个字节，name，引用类型变量，在32位系统下4个字节) 看不见的数据 : 编译器的对齐等 t表示一块内存，如何获取每个成员？ 编译器会根据一些编译的选项、数据的类型，在写好代码以后，定死一个数据成员相对这个类的内存的偏移，如age在对象实例里面，内存偏移多少，大小为age的类型(int 4字节) 当我们编写好一个类型后，编译器会知道 : 每个数据的相对于对象实例内存块的偏移 每个类的成员函数在代码段的偏移，因为最终是要把这些成员函数编译成机器指令，在运行时就可以让指令直接跳转到这里进行函数调用 什么是反射，反射有什么作用以Unity引擎为例 编辑器上挂脚本，我们给脚本初始化数据 编辑完了以后，保存到场景文件里面 运行的时候，根据场景文件里面的内容，游戏引擎把这个节点和组件实例new出来 上面我们描述一个类，每一个类都有一种类型，都有自己独立的描述 所以会导致我们每新加一个类，就会有多的一种方式来描述 上述问题的本质矛盾是 : 我们没有统一的方式来处理不同的类或类的实例 需要用一种方式来描述任意的类型 : 类的实例是一个内存块，内存块的大小就是这个类的所有数据成员的大小(通过编译器知道内存块大小) 类有哪些数据成员，我可以把这些数据成员的名字，通过数组等其他方式保存起来如 : 类有哪些成员函数如 : 任意的类都可以转化成一种描述 定义了这样一种描述方式，我们就解决了上面的问题，我们用统一的方式来描述任意不同的类型 类型描述 对象实例(Type, System)是什么 每个类，编译器都知道，数据成员的偏移、函数代码段的位置 运行的时候，C#系统会为每个类生成描述实例(数据内存)，称作Tpye实例；描述类的类型，称作Type类型，属于System名字空间 Type : 一些类型的描述信息伪代码 : 描述Test : 编译完成后，就可以根据编译信息，生成一个类型描述对象的数据，存起来，一起写入到.exe 底层就可以使用Type的方式来获得一个类的描述，可以根据类的描述来构建实例，调用方法和成员了 调用底层OS的API来分配一个xxxx大小的内存出来，作为对象实例的内存 调用构造函数，将这个内存块传递给构造函数，构造函数就会帮我们初始化对应的数据 编译每个类时，会为每个类生成一个全局数据，这个全局数据是Type类型，里面存放一个类的描述数据 只需要调用API : System.Type.GetType(“类型名字”) / typeof(T) 根据类型或类型名字获取类型描述对象实例 Type类型系统已经给我们定义好了，包含 : FieldInfo : 数据成员信息 MethodInfo : 方法信息 通过反射来实例化一个对象 : Type t实例化一个对象出来，根据t这个Type实例 API : Activator.CreateInstance Type里存放了每个数据成员的偏移和大小，用这两个数据，就能从对象的内存里面读取/设置成员的数据 从t里获取类型描述FieldInfo，结合t实例把大小、偏移等数据取出来就是数据的值了 API : SetValue/GetValue 每个Type里面都存放了成员函数地址 MethodInfo = t.getMethod(“名字”);Object returnObject = MethodInfo.Invoke(instance, 参数列表); 代码"},{"title":"Unity底层是如何处理C#的","date":"2023-06-18T06:58:45.000Z","url":"/2023/06/18/Unity-Underlying-Principle/","tags":[["unity","/tags/unity/"],["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Q1 : Unity的历史里面为什么会选择Mono？ Mono : 微软.net把.NET标准开放以后，Mono是一个跨平台的.net项目(Linux、Windows、Mac、Android等) 我们基于Mono来开发应用、开发游戏引擎、打包发布我们的游戏产品，都是可以跨平台的 Unity在设计的时候，为了跨平台，就采用了Mono来构建底层(Unity编辑器等) 快速地实现Unity编辑器以及Unity开发出来的app能够跨平台(主要原因) Q2 : Unity为什么又会推出il2cpp？il2cpp到底做了什么事情？ Mono .net的版权问题 .net本身也在迭代，每迭代上一个版本的时候都会有授权和版权的问题，这对Unity来说不是一个特别方便的东西，而是一个限制 Mono虚拟机解释执行.net的字节码，运行效率比较差 有些平台不允许内置.net虚拟机，比如IOS 如果有新的计算平台出现(如XBOX等)，Mono又不支持，这时Unity在跨平台上就没用了 整个Mono是另外一个项目的，如果要把Mono虚拟机移植到一个新的平台，可能要Unity自己动手，这时就会跟Mono主干分开。主干一个分支，Unity一个分支，这时维护起来是非常麻烦的 同时一些平台本就不好移植(如WebGL)，对Unity而言是非常被动的 这时，Unity推出了il2xxx技术 (xxx包括c++、javascript等) IL : .net字节码 IL2cpp : .net字节码 —&gt; C++代码，再编译，生成native平台相关东西 (1) Unity首先要开发一个C/C++以及native层，来做一个跨平台的Runtime(Xcode, Android NDK,…) (2) Unity引擎需要把游戏开发者的代码(.net字节码)，要开发一个工具(IL2CPP)，把它转成C++的代码，这些C++代码基于一些库，结合跨平台的层，生成目标平台的应用程序 (3) C#有垃圾回收机制等，这时C++代码就需要对这些垃圾回收等提供支持。Unity为了提供这些特性的支持，开发了il2cpp vm(实际上是一个runtime库) : 支持C#，.net独有的一些特性，如垃圾回收等 Q3 : il2cpp有哪些优势？ 跨平台可移植性问题 : Unity本身只需要来移植这个il2cpp就可以了，比较方便 解决.net版权问题 性能获得提升 : .net是解释执行字节码，il2cpp是把它变成C++代码，其实就是本地的native代码，运行效率会更高一点 基本上都是基于il2cpp来进行发布，性能会更好 "},{"title":"DOTS(2) DOTS中的ECS架构与概念术语","date":"2023-06-17T04:03:23.000Z","url":"/2023/06/17/dots-02/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Entity-Component-System实体组件系统(ECS)架构 遵循组合优于继承的原则 面向数据设计 弱耦合 常被应用在游戏开发上 游戏引擎架构演变 在ECS架构出现之前，早期的游戏引擎或游戏的架构，多以多层对象继承的方式来组织，都是按空间节点为较基础的对象，一层一层抽象继承下来的 后来随着发展，游戏引擎逐渐演变成以Actor Component这种以轻继承，以对象组合代替多层继承的方式来组织 其中Actor是个Component的容器，而负责具体逻辑更新部分则由具体的Component负责 对象几乎没有多态，做到了对象间的解耦 如Reality Engine、UE3以后的版本以及Unity几乎都是这种架构 我们要明确ECS架构的本质，组合的是数据数组，而非对象数组。其中Entity本身虽然叫做实体，但并非对象，也不是一个容器，而是一个对象索引的id，是一个标识符，其中并不包含任何数据与逻辑；而Component才是个容器，但它不是一个对象容器，而仅是一个数据容器，其中不包含任何逻辑。 Entity与Component的关系，往往是Entity充当数据的标识符或Key来使用，而ECS中的S(System)才是真正负责对数据进行操作的部分 换句话说，System才是对具有特定组件的特定实体执行的操作 DOTS1.0中的ECS ECS架构一直在演变 应用场景不同，各家实现和工作流有差异 DOTS1.0中的ECS与老版本变化较大，不要看老资料 DOTS1.0中，为了让大家从面向对象设计向面向数据设计编写代码时，过度更平滑些，引入了不少特性与专有名词，让大家在编写代码时能找到一些面向对象的感觉。因此我们在学习DOTS时，不要先入为主去质疑DOTS下的ECS为什么如此设计，要以DOTS下的ECS工作流方式去学习。另外DOTS中的ECS只是DOTS中的一部分，并不是你了解ECS架构，甚至自己动手实践过ECS就一定能学好 开发心态去接受 DOTS下关于ECS的专有名词和概念 Archetypes原型和Archetypes Chunk的概念 Archetypes依然不是个对象，它依然是一个标识符，它标识的是所有具有相同Component组合的实体类型 举个例子，这里由Position、Rotation、Renderer、Rigid Body四个Component组件组合成的Entity A与Entity B共享一种原型，而由Position、Rotation、Renderer三个组件组合成的Entity C则属于另外一种原型 这里可以将Archetype原型理解成不同的Entity在内存上的Layout布局 如图所示，26个Entity被分为8种原型，而每个Archetype原型所标记的内存会被分成固定大小连续的非托管内存块，被称为Archetype Chunk，这里简称Chunk Chunk中会包含共享同一原型的实体组件数组，默认设置下每个Chunk大小为16KB，如果实体组件填充不满的情况下，也要有留白 Chunk存在的目的，是为了方便做数据并行计算，方便做缓存的prefetch在数据对齐的同时又可以匹配缓存的catch line，另外在Query查询时，无论是使用主线程查询、工作线程并行查询、还是按Chunk查询时，都可以利用其在Component的数组纵向维度上分块对齐的方式来做slice切片 World与EntityManager的概念 World是一系列Entity的组合，每一个Entity在一个World中是唯一的，统一受到world中的EntityManager结构的管理 EntityManager负责创建、销毁、修改世界中的实体 Structural Change的概念 所有导致需要重新组织内存块或内存块内容的操作都称为Structural Change 这里包括两个重点，一个是改变结构，一个是改变内容，这两种改变都只能在主线程中做，而不能在工作线程中做，是Resource Intensity资源密集类型的操作，效率很差 应该能想到，添加或删除一个Entity对应的组件，导致所属原型发生变化，就属于Structural Change的概念 另外，创建和销毁Entity实体、设置Share Component值也会被视为Structural Change，要尽量避免 而当我们明确我们一定不会有Structural Change的操作时，我们可以在编辑时做Bake的操作，虽然会降低运行时的逻辑灵活性，但会提高运行时效率 这张图可能会造成误解 不同原型内的相同组件，在内存上并不是像上图这样是连续的，这只是为了展示在Query查询时，会通过slice切片方式来阻止查询，让你感觉上是连续的，但并不会造成内存上的移动 Entities and Components术语 System术语 DOTS下的ECS Entity : Entity不是一个容器，它只是一个标识符，它用来指示某个对象的存在。系统可以用它来操作，可以通过组件来分配某些属性 Component : 组件是一个数据容器，没有任何逻辑，一组特定的参数关联在一起并定义属性 System : 系统是负责对数据进行操作的部分。换句话说，系统是对具有特定属性(组件)的特定实体执行的操作 补充 类比例子并不是为了说明缓存分级的原因 而是用组织排队去理解面向数据设计，可以更形象的理解ECS、Jobs与Burst在DOTS中分别扮演哪些角色，做了哪些事 缓存分层的原因本质是物理距离决定的 "},{"title":"DOTS(1) 面向数据设计DOD","date":"2023-06-16T01:38:31.000Z","url":"/2023/06/16/dots-01/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"DOTS是面向数据的技术栈DO的缩写正是DOTS是以面向数据为基础的一个技术解决方案所以充分了解面向数据设计DOD是学习DOTS的基础 程序设计方法 这些程序设计方法都有很明显的时代特征，与程序语言的特性 Instructional Programming 指令化编程 正是计算机脱离纸带打孔输入后，伴随着机器汇编语言发展起来的 Functional Programming 函数化编程 伴随着Pascal语言出现的，以小函数模块化组合的编程范式 由于其限制小、易于调试等特点，主要用在数学和科学计算领域 如今如火如荼的机器学习、AI领域，函数化编程依然焕发着活力 Procedural Programming 过程化编程 是一种源于命令式的编程范式，基于过程调用的概念，包含一些要执行的步骤，任何给定的过程都可以在程序执行过程中的任何时刻调用 过程化编程伴随着一些更高级的编程语言，如Fortran、ALGOL、COBOL、BASIC等而出现 Object-Oriented Programming/Design 面向对象编程/设计(OOP/OOD) 随着程序化规模越来越大，传统的编程范式已不足以满足易于理解、易于设计的需要了，这时，面向对象设计和编程的方式开始出现了 它是以对象为概念的多范式模型，包含字段形式的数据与过程形式的代码，通常以类为基础，强调数据的封装、类的继承与对象的多态特征，程序开始有了更高级的设计的概念 随之是一系列相关设计模式，诸如C++、Java、Python等广泛使用的面向对象的多范式编程语言的出现 Data-Oriented Design(DOD) 面向数据设计 是伴随着现代CPU多核并行计算、多级缓存、大缓存的设计而流行起来的 这里的DOD并不是面向数据编程，它并不是一种编程范式，而DOTS更可以理解为面向数据编程的一种范式 OOD -&gt; DOD 我们需要有从OOD面向对象设计到DOD面向数据设计的思想转变 面向对象设计的核心在于抽象、封装和继承，这样的设计对人类来说可能更直观、易于理解，但对于现代CPU来说，它的处理效率并不高效 而面向数据设计则侧重于数据，开发人员需要考虑需要什么数据，以及如何在内存中更好的构造数据，以便CPU处理数据系统时能够更有效地访问数据 DOD面向数据设计的本质，可以理解为是面向内存或缓存友好的设计 这要从CPU架构与缓存层级结构说起 CPU中会设置L1、L2、L3，3级缓存 其中一级缓存为每个指令处理单元独享，又可分为缓存数据的L1 D数据缓存与缓存指令用的L1 I指令缓存 L2级缓存则为CPU核内多个指令处理单元共享 L3级缓存则为CPU多个核共享，同时它还负责与内存以及显卡中的显存交换数据 CPU在执行程序指令时，会通过prefetching来获取指令与数据，每次访问的单位会根据系统与架构的不同而有所差异，一般是32或64个字节，把这个基础大小单位称为catch line缓存行。即使你请求一个字节大小，实际上你会得到一个catch line大小的缓存行数据 而在catch缓存内，可以将n个缓存行大小的缓存通过direct map直接映射到同一逻辑缓存行，而逻辑缓存行可以对应n个物理行，来帮助最小化缓存行的抖动。这里的抖动可以理解为 : 扭动指针到每个物理缓存行头 CPU逻辑处理单元，通过Fetch获得L1 I指令缓存中的指令，再通过Decode解码Execution执行，以及在指令完成后将数据回写到L1 D中，来完成一条程序指令 我们可以把Fetch、Decode、Execution这样一个循环时间定义为一个CPU指令的Cycle CPU处理指令时，从不同的缓存Catch中获取数据的时间开销也是不同的，这会导致我们获取的数据在某一级缓存没有命中时，向下一级缓存获取时花费的时间开销可能是数倍时间，甚至是数量级差异的时间开销，因此我们在编写程序时，如何做好面向数据设计，以达到缓存访问友好，对程序性能开销至关重要 Cache的3C与3R 3C即缓存未命中的三种情况 Compulsory misses : 首次读取数据时，不可避免的Miss Capacity misses : 缓存空间不足时，连续使用期间访问数据过多的话，无法保存所有活动的数据 Conflict misses : 发生访问冲突时，由于数据映射到相同的缓存行，导致缓存的抖动 3C伪代码 : 当变量i = 0时，第一次进入循环，此时要访问data中的第一个int数据，这时catch中没有数据，会发生第一种情况下的Miss catch，这时需要进行profetching来加载一个catch line数据 接下来的第二遍循环会从catch line中加载数据，指令cycle数比第一次要少 当data数据足够大、循环次数足够多时(pointerToSomeData、1000000)，超过catch大小时会发生第二种情况，缓存不足导致的Miss catch 这里只是举例，真实情况不一定发生，而且现在GPU缓存很大，简单的代码触发缓存不足导致的Miss catch情况非常少 将 ++data 替换成 data+=16 时，这时会触发第三种缓存抖动带来的Misscatch，也就是实际数据访问不连续，一次catch line获取的数据并没有你需要的，这种情况发生比较多，尤其是我们使用数组结构体AoS的数据Layout时 3R即3种优化访问catch命中的方法 Rearrange 重新排列(代码、数据) : 更改布局以增加数据空间的局部性 Reduce 减少(大小、缓存行读取) : 更小更智能的格式、压缩，如修改数据类型或使用位计算 Reuse 重用(Cache lines) : 增加数据的时间(和空间)的局部性，主要是对齐、连续访问，减少发生缓存抖动的几率 面向数据设计需要思考的问题总之，面向数据设计需要我们更了解内存/缓存的特性，需要更了解系统和硬件，需要更了解芯片指令与数据结构设计，与面向对象设计相比，数据比代码更重要 DOTS面向数据设计原则 先设计，后编码 为高效使用内存与缓存而设计 为Blittable Data设计 为普通情况设计 拥抱迭代 "},{"title":"DOTS(0) DOTS的5W1H问题","date":"2023-06-14T08:07:04.000Z","url":"/2023/06/14/dots-00/","tags":[["unity","/tags/unity/"],["dots","/tags/dots/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 5W1H What——DOTS是什么 Who——谁需要关注DOTS Where——Dots可以应用到哪些地方 Why——为什么我们需要DOTS When——什么时候DOTS1.0能正式发布 How——我们该怎么样学习DOTS DOTS是什么 Data-Oriented Technology Stack(面向数据的技术栈) 实际上是通过Unity5个核心包来定义的一种全新的Unity代码编写模型，并在这些核心包之外，还提供了一系列游戏功能相关的额外包与相关工具，是Unity下面向数据设计与编程的一整套技术解决方案 它的五个核心包包括 : The C# job system : 用来提供快速安全和使用简单的编写多线程代码的方式，从而让开发者更容易地利用现代CPU的多核设计来处理并行任务 The Burst compiler : 这是一种优化C#代码的编译器，它可以编译生成比通过Mono或IL2CPP更快的代码，并且它并不只是为了编译DOTS代码而存在，它同样可以编译Unity中的任何代码 Unity Mathematics : 这是一套可以在job system中使用的数学库，它提供的功能在burst编译的代码中使用时是经过特别优化的 Unity Collections : 它提供了常见的集合类型，如列表、哈希映射表等，这些类型的内存分配属于非C#托管类型，可以在burst编译代码中的job system中使用，并且这些集合类型支持安全检查，有助于它们在job system中安全地使用 Entities(Unity ECS)(Entity-Component System) : 其中entity对象是GameObject更轻量、更高效的替代品，与GameObject和MonoBehaviour不同，entity本身并不承担任何代码，components也只是数据片段集合，它们都有对应的System代码单元进行处理 其他游戏功能相关的额外包包括 : Entities.Graphics(DOTS1.0之前的Hybird Renderer) : 它是一套支持URP与HDRP的entity渲染解决方案，值得注意的是，它并不是优化GPU上的性能，而是为了优化CPU上性能而设计的 Netcode : 这是一个建立在五个核心包基础上的DOTS网络解决方案，它提供了网络多人连线的服务器功能与客户端预测等相关功能 Physics : 同样是一个建立在五个核心包基础上的物理解决方案，这个包支持两个后端 : 默认的是Unity Physics包，它是一个无状态的确定性物理库，比较适合多人网络游戏；另外一个后端是Havok，这是一个有状态但不具备确定性的物理库，但相较而言这个库会更稳定，功能也会更强大 其他还有一些目前正在开发中的与游戏相关的额外包 Animation(WIP) Audio(WIP) 谁需要关注DOTS 技术负责人 处理游戏逻辑部分的工程师 处理网络通信部分的工程师 处理动画部分的工程师 处理物理模拟部分的工程师 开发工具与工作流相关内容的工程师 技术美术 AssetStore中DOTS相关工具与插件的开发人员 DOTS可以应用到哪些地方 具有大世界流式加载的游戏 具有复杂的大规模模拟的游戏 具有多种网络类型的多人联线游戏 具有需要客户端模拟预测的网络游戏，如射击游戏 这些都是一些多线程加载、通讯以及充分利用多核并行计算的游戏类型 总结就是CPU-bound类的游戏应用都可以考虑应用DOTS来做并行优化。目前很多游戏的性能瓶颈并不在渲染，而在CPU，这就是我们为什么需要DOTS 为什么我们需要DOTS CPU与Memory的速度发展不均衡以及带宽限制 是靠添加高速的缓存Cache内存层级结构去弥补的 如L1、L2、L3级的CPU缓存是最近十几年越加越多、越加越大的，甚至GPU上也为了效率采用了类似的设计 即使这样，一些程序设计的不合理依然会造成Cache使用上低效，导致大型缓存收益边界效益递减 而面向数据设计本身是面向缓存友好的，可以极大增加缓存Cache的命中，提高效率 摩尔定律的延续与现代CPU设计 越来越好的工艺，目前已经达到2nm极限了，那么提高CPU速度主要靠提高主频，提高功率的同时降低发热，在占用空间越来越小的同时通过增加核数做并行处理来提高处理能力，但需要做指令并行，改进编译技术的支持，才能发挥现代CPU设计的真正效能。这些条件下，如果你不去关心CPU指令与编译这一层是很难做到的，不要指望编译器能为你自动做这些事，编译器做的事很有限，程序性能的提升可远没有硬件提升这么快 据统计，程序性能每18年才能提高一倍，比摩尔定律要慢得多。另外，游戏主机硬件的发展也是不遵循摩尔定律的，因为它们往往是固定的硬件 所以DOTS是提供了一套更简单的面向数据的代码编写模型，用DOTS编写出的程序可以充分利用现代CPU多核的并行设计 并行编程的发展 并行编程库虽然有英特尔TBB(Intel Threading Building Blocks)、OpenMP、CUDA(Compute Unified Divice Architecture)、OpenCL(Open Computing Language)等很多，但它们要么依赖于特定的硬件，要么是针对于科学计算方面设计的，集成到Unity中使用几乎是不可用的 DOTS则充分考虑了游戏设计方面的需求，并在Unity中兼容了多平台多硬件的支持 什么时候DOTS1.0能正式发布(略) 我们该怎么样去学习DOTS 看 : 视频、官方文档、官方论坛DOTS区，官方Github中例子代码 查 : 专业术语、相关概念、扩展资料 学 : 五大核心包、游戏扩展包、三方扩展包与工具 改 : 官方Github中例子、Unity Assets Store中的例子 调 : 官方Github例子，自己的Demo 写 : Demo，小工程、DOTS游戏 交流 : 官方论坛，社交媒体群，评论区等 "},{"title":"Unity面试题搜集（一）","date":"2023-06-10T03:49:28.000Z","url":"/2023/06/10/questions-1/","tags":[["unity","/tags/unity/"],["面试题","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"categories":[["undefined",""]],"content":"&nbsp; 面试必问题目之一：先来个简单的自我介绍吧！ 面试必问题目之二：你对自己的发展有什么规划？ 面试必问题目之三：你觉得你的优势是什么？ 面试必问题目之四：工作中遇到的比较难处理的问题是什么?如何解决的? 面试必问题目之五：你对公司有什么想了解的吗 题目大多由个人面试所总结，不同岗位的面试的侧重点都是不同的，以下仅供参考 PS：很多面试其实更关注的是你的项目经历，以及你简历里所填写的内容 AssetBundle读取时主要用的方法是什么？ AssetBundle.LoadFromFile：从本地文件系统加载AssetBundle。 AssetBundle.LoadFromMemoryAsync：从内存异步加载AssetBundle。 AssetBundle.LoadFromStreamAsync：从流异步加载AssetBundle（可以是网络流或本地文件）。 AssetBundle.GetAllAssetNames：获取所有资源名称列表。 AssetBundle.LoadAssetAsync：异步加载指定类型的资源（例如场景、纹理、模型等）。 Assetbundle.Unload: 卸载已经加载过的AssetBundle以及其依赖项。 LightMap是什么？有什么作用？ 光照贴图，是一种纹理类型，编码格式取决于不同的平台 预先计算场景中物体表面的亮度，可以包含直射光和间接光，并将结果存储在LightMap中供以后使用 通过降低实时光照计算量，在保证效果的同时，大幅提升游戏性能，适合性能较低的硬件，如移动平台 打包有使用过什么自动化工具吗？ OrangeStudio Assetbundle插件：自动打AB包、自动加密AB包 RenderTexture是什么，它有什么作用？ 一种特殊的Texture类型，本质是将一个FrameBufferObject连接到一个server-side的Texture对象 可以显示一个摄像机渲染的画面 FrameBuffer就是gpu里渲染结果的目的地，我们绘制的所有结果（包括color depth stencil等）都最终存在这个这里，有一个默认的FBO它直接连着我们的显示器窗口区域，就是把我们的绘制物体绘制到显示器的窗口区域。但是现代gpu通常可以创建很多其他的FBO，这些FBO不连接窗口区域，这种我们创建的FBO的存在目的就是允许我们将渲染结果保存在gpu的一块存储区域，待之后使用 在渲染过程中，贴图最开始是存在cpu这边的内存中的，这个贴图我们通常称为client-side的texture，它最终要被送到gpu的存储里，gpu才能使用它进行渲染，送到gpu里的那一份被称为server-side的texture。这个tex在cpu和gpu之间拷贝要考虑到一定的带宽瓶颈 unity的RenderTexture将这个fbo直接关联一个gpu上的texture对象，这样就等于在绘制时就直接绘制到这个texure上，这样也省去了拷贝时间 谈一谈你所知道的Unity内存优化方法 博客 什么是DrawCall？如何降低DrawCall？ 每次CPU准备数据并通知GPU的过程就称之为一个DrawCall Unity中的碰撞器和触发器的区别？ 如何处理AssetBundle资源依赖问题？ Unity3d中的灯光有哪些？ 有接过SDK吗？ 动态加载资源的方式有哪些？ RectTransform和Transform的关系和区别是什么？ 请尝试写一个跟踪弹逻辑（平滑跟踪） 如何安全的在不同工程间安全地迁移asset数据？ 向量的点乘、叉乘以及归一化的意义是什么？ Unity3d的物理引擎中，有几种施加力的方式，请分别描述出来 MeshRender中material和sharedmaterial的区别？ 什么是渲染管线？并写出渲染管线的3个阶段，说出顶点着色器和片元着色器在其中的哪些阶段进行 简述四元数Quaternion的作用，四元数对欧拉角的优点？ 单例模式的作用和缺点是什么？ UI框架是如何实现的？ 如何用Animtor做融合动画？ 在项目里都用过哪些设计模式？ Lua多继承如何实现？ UI多层级叠加是如何处理的 写一个算法，将数字67、58、43先转换为二进制，再转换为12位字符串(不够12位的话用0补齐)。如5的二进制为101，对应的12位字符串为000000000101 JSON和XML的区别是什么？ Lua为什么能进行热更新？ 请用Shader实现简单的Phong光照模型，至少包含放相关和环境光的计算 Lua和C#是如何进行交互的？ 请使用一个int变量记录多个状态？如记录英雄同时存在跑步、攻击、跳跃等状态，并判断英雄是否有某个状态 请写一个你熟悉的游戏类型（如贪吃蛇），并说明这个游戏类型可抽象出哪些模块 如何优化性能、内存、包体大小？有借助什么工具？ 不同的手机设备尺寸分辨率都不一样,该如何进行适配? LineRenderer中的关键参数有哪些？ Unity中如何知道一个游戏包体大小，具体的素材占用情况？ 说一下游戏中的对象池有什么作用，如何实现？ 如何处理场景中物体的点击事件？ 事件中心有什么作用？如何实现？ TCP协议与UDP协议的区别 请简述GC产生的原因，并描述如何避免？ LOD和MipMap分别是什么？并简要描述他们的优缺点 Lua中pairs 和 ipairs区别是什么？ 请为任意类型的数组，拓展一个获取数组中随机索引对应值的方法 反射的实现原理是什么？"},{"title":"games101_L09_着色3(纹理映射 续)","date":"2023-04-15T13:10:59.000Z","url":"/2023/04/15/games101-L09/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L08_着色2(渲染管线、纹理映射)","date":"2023-04-15T06:23:10.000Z","url":"/2023/04/15/games101-L08/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L07_着色1(光照、着色)","date":"2023-04-15T04:42:36.000Z","url":"/2023/04/15/games101-L07/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L06_光栅化(续) 反走样与深度缓冲","date":"2023-04-14T11:50:00.000Z","url":"/2023/04/14/games101-L06/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L05_光栅化","date":"2023-04-13T10:38:22.000Z","url":"/2023/04/13/games101-L05/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L04_变换 (续)","date":"2023-04-13T10:38:18.000Z","url":"/2023/04/13/games101-L04/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L03_变换","date":"2023-04-11T12:54:50.000Z","url":"/2023/04/11/games101-L03/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"games101_L02_线代综述","date":"2023-04-11T12:54:46.000Z","url":"/2023/04/11/games101-L02/","tags":[["games101","/tags/games101/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"算法与数据结构_6_","date":"2023-03-29T05:22:21.000Z","url":"/2023/03/29/LeetCode-6/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; "},{"title":"算法与数据结构_5_二叉树","date":"2023-03-22T11:26:36.000Z","url":"/2023/03/22/LeetCode-5/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 二叉树 二叉树节点结构 一个值类型 一个指向左孩子的指针 一个指向右孩子的指针 左孩子、右孩子都为空的叫做叶节点 最顶的节点叫做根节点或头节点 二叉树的遍历，最简单是递归 先序 (头左右) : 递归序中第一次遇到该节点 中序 (左头右) : 递归序中第二次遇到该节点 后序 (左右头) : 递归序中第三次遇到该节点 非递归先序 流程 : 准备一个栈，先把头节点放进去 每次 : 从栈中弹出一个节点cur 打印(处理)cur 先右再左(如果有) 周而复始 非递归后序 流程 : 准备一个栈，先把头节点放进去，再准备一个收集栈 每次 : 弹当前节点cur cur放入收集栈，弹一个放一个 先压左再右 周而复始 非递归中序 流程 : 每颗子树，整棵树左边界进栈，依次弹的过程中，打印，对弹出节点的右树重复 如何直观打印一颗二叉树 如何完成二叉树的宽度优先遍历 宽度遍历(层序遍历)用队列，头部进尾部出，先进先出，先放左孩子再放右孩子 常见题目 : 求一棵二叉树的最大宽度 二叉树的相关概念及其实现判断如何判断一颗二叉树是否是搜索二叉树 搜索二叉树 :对于每一颗子树来说，都满足 : 左数的节点都比它小，右树的节点都比它大(没有重复值) 中序遍历 如何判断一颗二叉树是否是完全二叉树 完全二叉树 :每层是满的，最后一层即使不满，也是从左往右变满的情况 判断条件 : 1)任一节点，有右无左返回false 在1)不违规的条件下，如果遇到了第一个左右孩子不双全的情况下，那么接下来遇到的节点都为叶节点，否则返回false 如何判断一颗二叉树是否是满二叉树 麻烦做法 :先求最大深度L，再求节点个数N，满足深度N = 2^L - 1 如何判断一颗二叉树是否是平衡二叉树 平衡二叉树 :对于任何一颗子树来说，左树与右树的高度差不超过1递归套路，返回两个信息，是否平衡和高度 树型DP的题，用递归套路，在可以向左右树索取信息的想法下 题目 : 给定两个二叉树的节点node1和node2，找到它们的最低公共祖先节点(首个汇聚的点) 在二叉树中找到一个节点的后继节点 后继节点 :中序遍历中，一个节点的下一个节点 二叉树的序列化和反序列化就是内存里的一颗树如何变成字符串形式 做法 :先序遍历，数值直接写，值的结束用下划线_，遇到null用特殊字符#下划线换成用逗号分割，类似数组先建头节点，先建左子树，遇到空(#)返回上级建右子树 题目 : 对折一张纸n次打开，请打印出折痕凹凸情况规律 : 每次对折后，在上一次的每个折痕的上下都会出现一个新的折痕，上面的是凹折痕，下面的是凸折痕 这是一颗头节点为凹折痕，每一棵左子树都是凹折痕，每一颗右子树都是凸折痕的满二叉树 "},{"title":"算法与数据结构_4_稳定性、排序算法总结、综合排序、哈希表、有序表","date":"2023-03-20T11:57:48.000Z","url":"/2023/03/20/LeetCode-4/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 稳定性 值排完序后相同的值，次序不变 排序算法总结 总结： 一般来讲，选择快排，因为参数项较优 空间实在不够时用堆排 需要稳定性时用归并 基于比较的排序，目前找不到时间复杂度在O(N * logN)以下的 基于比较的排序，在时间复杂度O(N * logN)时，目前找不到空间复杂度做到O(N)以下且稳定 常见的坑： 归并排序的额外空间复杂度可以变成O(1)，非常难不需要掌握，搜“归并排序 内部缓存法”，那时稳定性会丧失，那为什么不用堆排呢 “原地归并排序”的帖子都是垃圾，它让额外空间复杂度变成O(1)，但时间复杂度变成O(N^2)，那为什么不用插入呢 快排可以做到稳定性，非常难不需要掌握，搜“01 stable sort”，做到的同时会让额外空间复杂度变成O(N)，那为什么不用归并呢 所有的改进都不重要 有一道题目，一个整形数组，请你做到奇数放到左边，偶数放到右边，还要求奇数之间的相对次序不变，偶数之间的相对次序不变，要求额外空间复杂度O(1),还做到时间复杂度O(N)。这是面试官在搞你。因为分奇偶相当于快排的partition，做不到稳定性。 综合排序 根据样本量 和 各自的排序算法的优势 选择不同的排序方式 工程上对排序的改进 充分利用O(N * logN)和O(N^2)排序各自的优势。如&lt;60用插入，&gt;=60用归并 稳定性的考虑。如基础类型用快排，自定义类型用归并 哈希表、有序表哈希表 在C++中叫 : UnOrderedMap / UnSortedMap 、 UnOrderedSet / UnSortedSet 在Java中叫 : HashSet / HashMap Map、Set Map : Key -&gt; Value Set : Value 唯一的区别是 有无伴随数据 Java示例： 哈希表在使用(增删改查)时，时间复杂度都认为是常数级别(比较大的常数)O(1)，且跟数据量无关 哈希表在使用层面上可以理解为一种集合结构 放入哈希表的东西，是基础类型(Java中包括String)，按值传递，一律拷贝一份放表里；不是基础类型，按引用传递，内存占用是这个东西内存地址大小，一律8字节 有序表 在C++中叫 : OrderedMap / SortedMap 、 OrderedSet / SortedSet 在Java中叫 : TreeSet / TreeMap Java示例： 有序表把key按照顺序组织起来 性能上比哈希表差一点，所有操作都是O(logN)级别的 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同 放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是内存地址大小 链表 单链表、双链表结构 题目 : 给定一个单链表的头节点head，请判断该链表是否为回文结构。例子 : 1-&gt;2-&gt;1，返回true; 1-&gt;2-&gt;2-&gt;1，返回true; 1-&gt;2-&gt;3，返回false。要求 : 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。 方法一 : 方法二(快慢指针) : 将单向链表按某值划分成左边小、中间相等、右边大的形式 题目 : 给定一个单链表的头节点head，节点的值类型是整形，再给定一个整数pivot。实现一个调整链表的函数，将链表调整成左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。 进阶要求 : 再实现原问题功能的基础上增加如下要求 调整后三部分里所有节点之间的相对顺序和调整前一样 时间复杂度达到O(N)，额外空间复杂度达到O(1) 笔试做法 : 申请一个Node类型数组，把每一个值放进去，在这个数组上patition(没稳定性) 面试做法 : 复制含有随机指针节点的链表 题目 : 一种特殊的单链表节点类描述如下class Node{ int value; Node next; Node rand; Node(int val) { value = val; }}rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。 要求 : 时间复杂度O(N)，额外空间复杂度O(1)。 题目 :给定两个可能有环也可能无环的单链表，头节点head1和head2.请实现一个函数，如果两个链表相交，请返回相交的 第一个节点；如果不相交，返回null。要求 :如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。 法一 哈希表:使用一个哈希表(Set)，每往下走一个节点，查询一遍该节点是否已存在哈希表中，直到next走到null或相同为止 法二 快慢指针:如果快慢指针能相遇，则有环，这时让快指针回到head，两指针一起一步一步走，会在环的第一个节点相遇 "},{"title":"算法与数据结构_3_快排、堆、比较器","date":"2023-03-19T03:16:26.000Z","url":"/2023/03/19/LeetCode-3/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 快排 额外空间复杂度：好情况O(logN),差情况O(N) 完全二叉树 左孩子 : 2 * i + 1右孩子 : 2 * i + 2父节点 : (i - 1) / 2 有N个节点时，高度是logN级别 heapInsert时，只关心父节点的路径上走多少高度，所以用户新加一个数字时，调整的代价是O(logN)级别 用户想删掉一个数，并让剩下的数重新调整堆的代价也是O(logN)级别 堆 堆结构就是用数组实现的完全二叉树结构 完全二叉树分为大根堆、小根堆 大根堆 : 每个子树最大值都是头节点 小根堆 : 每个子树最小值都是头节点 堆结构的heapInsert和heapify操作 维持大根堆 : 将每次放进数组的值跟它的父节点的值做比较并调整，这个过程称为heapInsert heapInsert : 假设用户需要返回最大的数，这个数就是arr[0] 假设用户需要删除最大的数，做法是 :交换第一个和最后一个数，同时heapsize–，不断比较两个孩子中最大的一个与父节点的大小，并调整，这个过程称为heapify heapify : 堆结构的增大和减小 heapSort 用户加数O(NlogN),heapify时O(NlogN),整体O(NlogN),额外空间复杂度O(1) mergeSort额外空间复杂度O(N),快排O(logN) 如果用户一股脑给出所有数组，要求弄成大根堆，可以从后往前做heapify，从倒数第二层开始，都只用往下进行一次heapify 这时时间复杂度 :(如果数组中有N个数，想象成满二叉树，这时最底层节点N/2个)T(N) = N/2 + N/4 * 2 + N/8 * 3 + N/16 * 4 + …2T(N) = N/2 * 2 + N/2 * 2 + N/4 * 3 + …T(N) = N + N/2 + N/4 + N/8 + … = O(N) 优先级队列结构，就是堆结构 堆排序扩展题目 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序 比较器 实现Comparator接口，重载int compare()方法，可写成内部类 对于sort排序如果返回负数，认为第一个参数应该放在前面如果返回正数，认为第二个参数应该放在前面如果返回0，认为谁在前面都行 对于new PriorityQueue&lt;&gt;(new AComp())的创建如果返回负数，认为第一个参数应该放在上面如果返回正数，认为第二个参数应该放在上面如果返回0，认为谁在上面都行 不基于比较的排序 不基于比较的排序 必须分析数据状况来定制 计数排序 员工的年龄，建一个数组age[200],遍历一般，将下标对应成年龄来计数，如 1岁 arg[1]++。O(N) 基数排序 [17 13 25 100 72]排序，先看最大的数字是几位按十进制数看[017 013 025 100 072]准备容器(可以是数组/队列/栈)，叫做桶这里假设桶是队列，准备10个桶先根据各位数字来 017放到7号桶 013放到3号桶 …把桶中的所有数字依次倒出来[100 072 013 025 017]再按十位数决定进哪个桶 100进0号桶 072进7号桶 …把桶中的所有数字依次倒出来[100 013 017 025 072]最后按百位数字决定进哪个桶 100进1号桶 013 017 025 072进0号桶把桶中的所有数字依次倒出来[013 017 025 072 100] 基数排序代码 "},{"title":"算法与数据结构_2_递归、master公式、归并排序、荷兰国旗问题、快排","date":"2023-03-18T02:08:32.000Z","url":"/2023/03/18/LeetCode-2/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 递归 算中点距离： mid = (L + R) / 2 : L + R可能越界 mid = L + (R - L) / 2 : 更好 等同于 L + (R - L) &gt;&gt; 1 : 右移一位比/2要快 递归求一个数组的最大值 master公式 T(N) = a * T(N / b) + O(N^d) T(N) : 母问题规模 T(N / b) : 子问题的规模 a : 子问题的调用次数 O(N^d) : 除去调用之外，剩下的过程的时间复杂度 只要是满足子问题等规模的递归，都可以用master公式求解时间复杂度 logb^a &lt; d O(N^d)logb^a &gt; d O(N^logb^a)logb^a == d O(N^d * logN) 归并排序 小和问题 荷兰国旗问题 给定一个整形数组和一个数，要求按这个数将数组分为3个区域，&gt; == &lt;。 [i] &lt; num, [i] 和&lt; 区域下一个交换, &lt;区域右扩, i++ [i] == num, i++ [i] &gt; num, [i] 和&gt; 区域前一个交换, &gt;区域左扩, i不变 快速排序 快排1.0 拿最后一个数num做划分 前面的数 &lt;= num的放左边, &gt; num的放右边 大于区域的第一个数和num做交换 让左侧和右侧重复这个行为 快排2.0 利用荷兰国旗问题，一次搞定一批相等的数，比1.0快 用最后一个数num做划分 前面的数分成 &lt;num ==num &gt;num三个区域 把num和&gt;num区域第一个数交换 让左侧和右侧重复这个行为 快排3.0 随机选一个数，放在最后，拿它做划分值num 时间复杂度变成O(N * logN) "},{"title":"算法与数据结构_1_选择排序、冒泡排序、异或运算、插入排序、二分法","date":"2023-03-17T08:17:32.000Z","url":"/2023/03/17/LeetCode-1/","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 选择排序 冒泡排序 异或运算(^) 相同为0，不同为1 还可以理解成：无进位相加 性质： 面试题： 在一个整形数组int[] arr中，1）已知只有一种数出现了奇数次，其他的所有数都出现了偶数次怎么找到出现了奇数次的数2）已知有两种数出现了奇数次，其他的所有数都出现了偶数次怎么找到这两种数要求：时间复杂度O(N),额外空间复杂度O(1) key: 2） 插入排序 时间复杂度O(N^2),额外空间复杂度O(1) 插入排序在某些数据状况下并不是严格的O(N^2)，会优于选择/冒泡排序 时间复杂度 O是按算法最差情况下的时间复杂度， θ是平均状况下的时间复杂度， Ω是最好情况下的时间复杂度，后两个指标实际用处不大，可以不记，只用记O 二分法 在一个有序数组中，找某个数是否存在 遍历找一个数的方法，时间复杂度O(N) 二分法找，先找数组最中间的数，因为有序，所以可以砍掉一半，继续二分，时间复杂度O(log2^N)，默认都写成log(N) 8个 4个 2个 1个 log2^8 = 砍3次 在一个有序数组中，找&gt;=某个数最左侧的位置 做记号，二分到结束为止 局部最小值问题 数组无序，相邻数一定不相等 "},{"title":"Java笔记(3) —— 原码、反码、补码，位运算符","date":"2022-12-14T10:22:43.000Z","url":"/2022/12/14/JavaStudy-3/","tags":[["Java笔记","/tags/Java%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"&nbsp; 二进制在运算中的说明 二进制是逢2进位的进位制，0、1是基本算符。数字1在不同的位上表示不同的值，按从右至左的次序，这个值以二倍递增 现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是用二进制数来表示的 对于有符号的而言： 二进制的最高位是符号位：0表示正数，1表示负数 (0 -&gt; 0, 1 -&gt; -) 正数的原码、反码、补码都一样 负数的反码 = 它的原码符号位不变，其他位取反 负数的补码 = 它的反码 + 1， 负数的反码 = 负数的补码 - 1 0的反码、补码都是0 java没有无符号数，换言之，java中的数都是有符号的 在计算机运算的时候，都是以补码的方式来运算的 当我们看运算结果的时候，要看它的原码 位运算符java中有7个位运算符(&amp;、|、^、 ～、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;): &amp;：按位与两位全为1，结果为1，否则为0 |：按位或两位有一个为1，结果为1，否则为0 ^：按位异或两位有一个为0，一个为1，结果为1，否则为0 ～：按位取反0 -&gt; 1, 1 -&gt; 0 例： 2&amp;3 = int是4个字节，1个字节8比特，最开头是符号位 2的补码 = 2的原码 00000000 00000000 00000000 00000010 3的补码 = 3的原码 00000000 00000000 00000000 00000011 2&amp;3运算后的原码：00000000 00000000 00000000 00000010 结果为2 ～-2 = -2的原码 10000000 00000000 00000000 00000010 -2的反码 11111111 11111111 11111111 11111101 -2的补码 11111111 11111111 11111111 11111110 取反操作 00000000 00000000 00000000 00000001 得到的是补码 取反后的原码 = 它的补码 结果为 1 ～2 = 2的原码 00000000 00000000 00000000 00000010 2的补码 00000000 00000000 00000000 00000010 取反操作 11111111 11111111 11111111 11111101 反码 11111111 11111111 11111111 11111100 原码 10000000 00000000 00000000 00000011 结果为 -3 **&gt;&gt;**：算术右移低位溢出，符号位不变，并用符号位补溢出的高位 **&lt;&lt;**：算术左移符号位不变，低位补0 **&gt;&gt;&gt;**：逻辑右移/无符号右移低位溢出，高位补0 无”&lt;&lt;&lt;”符号 例： int a = 1&gt;&gt;2; 1 = 00000000 00000000 00000000 00000001 右移2位 1 = 00000000 00000000 00000000 00000000 (01) = 0 本质相当于 1 / 2 / 2 = 0 int a = 1&lt;&lt;2; 1 = 00000000 00000000 00000000 00000001 左移2位 1 = 00000000 00000000 00000000 00000100 = 4 本质相当于 1 * 2 * 2 = 4 "},{"title":"Java笔记(2) —— 进制转换","date":"2022-12-12T14:21:58.000Z","url":"/2022/12/12/JavaStudy-2-DecimalConversion2-8-10-16/","tags":[["Java笔记","/tags/Java%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"&nbsp; 进制介绍 对于整数，有四种表示方式： 二进制： 0、1 满2进1 以0b或0B开头表示 八进制： 0-7 满8进1 以数字0开头表示 十进制： 0-9 满10进1 十六进制： 0-9及A(10)-F(15) 满16进1 以0x或0X开头表示 (A-F不区分大小写) 例： 2、8、16 ——&gt; 10 从最低位开始，将每个位上的数提取出来，乘以进制数的**(位数 - 1)**次方，然后求和 例： 0b1011 = 1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 11 01010 = 0 * 8^0 + 1 * 8^1 + 0 * 8^2 + 1 * 8^3 = 520 0x10101 = 1 * 16^0 + 0 * 16^1 + 1 * 16^2 + 0 * 16^3 + 1 * 16^4 = 65793 10 ——&gt; 2、8、16 将该数不断除以进制数，直到商为0为止，然后将每步得到的余数倒过来，就是对应的进制 例： 34/2 = 17 ··· 017/2 = 8 ··· 18 / 2 = 4 ··· 04 / 2 = 2 ··· 02 / 2 = 1 ··· 0 34(十进制) = 0b00100010(二进制) 2 ——&gt; 8 从低位开始，将二进制数每三位一组，转成对应的八进制数即可 例： 0b11010101 =0b11(3)010(2)101(5) = 0325 2 ——&gt; 16 从低位开始，将二进制数每四位一组，转成对应的十六进制数即可 例： 0b11010101 =0b1101(13-&gt;D)0101(5) = 0xD5 8 ——&gt; 2 将八进制数每一位，转成对应的一个3位的二进制数即可 例： 0237 =02(010)3(011)7(111) = 0b010011111 16 ——&gt; 2 将十六进制数每一位，转成对应的一个4位的二进制数即可 例： 0x23B =0x2(0010)3(0011)B(1011) = 0b001000111011 "},{"title":"性能优化(40)——发布优化——打包优化","date":"2022-11-25T05:04:28.000Z","url":"/2022/11/25/performanceOptimization-35/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; AssetBundle AssetBundle是一个存档文件，包含运行时加载的特定平台的非代码资源，与彼此之间的依赖关系 AssetBundle可以用于资源更新，减少安装大小，针对平台加载优化资源，减轻运行时内存压力 AssetBundle是一个容器，包含存档文件包头、以及序列化类型文件与资源文件 构建AssetBundle参考策略 根据对象的修改频率差异拆分不同的AssetBundle 具有相同生命周期的资源打成一个AssetBundle，如果一个AB中只有不到50%的资源经常加载，可以考虑拆到不同的AssetBundle中 不可能同时加载的高低配置资源拆分到不同的AssetBundle 如果多个对象依赖于某个AssetBundle中的单个资源，这类单个资源可以单独打包或者根据生命周期将这类被多个对象依赖的资源打成共享AssetBundle 如果一组对象只是一个对象的不同版本，可以考虑使用AB变体（注意Addressable不支持AB变体） 构建AssetBundle值得注意的点 AB包体不能因为避免重复引用，拆得过于细碎，2M-5M的包体是一个合理的参考值（移动平台下）。过小的包体，包头占用内存压力会比较大。一些操作系统，如IOS，也会有同时开启多个文件具体的数量限制，很容易就超过系统限制上限了；另外资源加载与销毁，反复创建销毁文件句柄，会造成系统资源开销大，电量消耗也会加大 LZMA格式压缩的AB包较小，但需要完全解压后再加载，加载时间更长，LZ4格式压缩的AB包按块加载，加载时间较快，但包体大小较大，移动平台建议使用LZ4压缩格式 如果确定使用相同版本Unity发布打包，后续开发不会升级Unity版本，AB包体不做Unity版本兼容时可以尝试开启打包选项BuildAssetBundleOption.DisableWriteTypeTree选项，这样TypeTree信息不会被打到AB中，可以极大减小包体大小及运行加载时的内存开销 避免同一个资源被打入多个AB中，会增加运行时内存开销，可以使用UPR Assets Checker工具来做检查。某些情况下，Unity创建资源时，会默认引用一些Unity内置资源，打包时不注意的情况下，这份内置资源会被打到多个AB包中。如创建默认粒子时，默认引用Unity内置资源DefaultParticle.png,如果要避免这种情况，可以用自定义资源替换默认引用资源 不要使用AB包文件的MD5值作为更新包依据，因为可能包内资源没有变化的情况下，生成的AB包MD5值也会发生变化，一般可以选择计算包内原始资源的MD5值和路径变化作为AB包变化的依据 "},{"title":"性能优化(39)——发布优化——启动时间优化","date":"2022-11-23T10:22:45.000Z","url":"/2022/11/23/performanceOptimization-34/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 可分为两部分：启动到LOGO出现（Unity Pro版可以理解为自定义的Splash界面），LOGO出现到场景出现 在移动平台上，IOS和安卓平台的启动流程是有差异的 IOS平台启动时间优化 Pre main过程：是通过一系列镜像二进制文件操作加载可执行文件、加载动态链接器、dyld（the dynamic link editor）、通过dyld递归加载所有动态链接库（dyLib）的过程，按苹果官方说法，就是分析镜像文件、映射镜像文件、设定并绑定镜像文件、镜像文件初始化这几个过程 Main()函数执行过程：主要包括UnityInitTrampoline、UnityInitRuntime，以及通过UIApplicationMain启动UnityAppController，并带动ios相应的controller、view之间的调用与回调，并在didFinishLaunchingWithOptions回调函数中做UnityInitApplicationNoGraphics初始化。其中UnityInitTrampoline函数中主要是crash reporter的初始化与新iosAPI对应的替换工作。而UnityInitRuntime主要做各种配置的读取，设置各种运行时参数，解析gfx设备相关参数与初始化Unity Player，并在此阶段初始化文件系统与各个运行时模块初始化和clear up的注册工作。而UnityInitApplicationNoGraphics主要是做mono或il2cpp以及虚拟机的初始化，PlayerInitEngineNoGraphics过程与创建UI闪屏，并做UIStatusBar初始化工作。 到此为止，黑屏阶段结束，进入startUnity过程 ios main函数执行过程，可以通过查看导出的ios工程学习。但UnityInitRuntime以及UnityInitApplicationNoGraphics过程则需要有Unity引擎代码才能知道其中的细节 以上三个ios启动的过程，Pre main与start Unity这两块是我们可以通过一些手段来优化的，而ios main函数执行过程与回调过程需要有引擎源码才能做深入优化 IOS平台程序启动需要注意的点 不同的ios系统程序启动的时间会因ios版本的不同而略有差异 ios程序启动分为安装后首次启动、冷启动、热启动 冷启动：杀掉程序后重新启动 热启动：程序进入后台后再切回前台，一些资源和设备状态恢复的过程 一般我们所说的启动优化是指优化冷启动 启动时间超过20秒的程序会被系统自动杀掉 Unity默认竖屏程序比横屏程序启动时间略长，但这个差异一般情况下不明显 推荐Pre main过程耗费的时间最好不要超过400ms 这个过程在IOS14之前的版本，可以通过开启DYLD_PRINT_STATISTICS或DYLD_PRINT_STATISTICS_DETAIL到环境变量，然后在控制台输出信息中查看 但在IOS15版本以后，这个环境变量不起作用了，但可以借助XCode的Instruments Time Profiler查看整体的启动流程和时间消耗 IOS Pre Main阶段优化建议 要做镜像文件的瘦身动作，合并重复或删除用不到的一些代码 针对Unity引擎，在IOS Player Setting下开启Strip Engine Code来减少Unity引擎库大小，如果是一些第三方库，可以通过App Code检测当前没有使用到的类和代码并删除 减少不必要的Framework与引用的动态链接库的加载 使用Static Archives链接dyLib C++代码中减少全局静态变量的使用，以及过度抽象，注意虚函数表的开销（一般超过10000个的虚函数库会有明显的加载开销） OC对象将在+load方法中要做的事延迟到+initialize方法中 减少OC对象的metadata。比如减少OC的Class、Selector以及Category的数量 在运行initializers中尽量不要调用dlopen，不要创建线程 注意一些第三方库与平台SDK。它们经常是造成黑屏时间长的主要问题 Andorid平台启动时间优化 Andorid平台程序启动需要注意的点 不同版本的Andorid系统程序启动时间略有差异 Android启动分为首次启动、冷启动、热启动，一般我们所说的优化是指冷启动 App进入后台可能会被系统自动杀掉，恢复也算冷启动 Unity中Activity的andorid:launchMode属性一定要保证是SingleTask的，否则原生界面调出，或切到后台等都可能发生崩溃 通过adb logcat查看日志中Displayed标签来查看程序启动到显示前时间 通过Android Studio的Android CPU profiler工具来定位启动时瓶颈 通过GooglePlay的Android vitals来发现启动异常问题 一些三方库与平台SDK对启动时间的影响 Andorid启动优化建议 减少Activity onCreate函数中复杂的逻辑工作 将所有的资源初始化做Lazy Load放到不同的线程中，不要全部放到主线程中 ios下的start unity过程与Andorid下的start up过程的优化建议 这个过程的优化完全可以在unity编辑器下完成 "},{"title":"性能优化(38)——发布优化——耗电量与发热量优化","date":"2022-11-21T02:09:34.000Z","url":"/2022/11/21/performanceOptimization-33/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 准备 测试手机的耗电量与发热量前，需要检测手机电池是否健康。健康度是否良好，是优化的前提 除了一些手机自带的电池健康度、温度接口外，还可通过第三方工具进行检测，如XCode的耗电量分析、UPR的耗电与电池温度监测等 功耗与发热量优化 功耗与手机发热的本质依旧是性能优化问题，现代手机芯片都会设定一个手机临界温度，在手机触发这个温度墙时，系统为了保护硬件，会对芯片做降频处理，这直接会导致手机运行游戏时出现掉帧的情况。一般来说，一些大型3D手游都会遇到这个温度墙。降频后，随着硬件温度的下降，系统还会让芯片恢复正常的频率。我们的优化主要是推迟触碰到温度墙后的降频发生时间，以及让这个降频时间缩短 温度过高是导致系统降频的直接原因，导致温度升高的原因有： 抛开我们控制不了的部分，针对于手机发热问题，我们只能从CPU、GPU负载、显示、GPS、网络通讯与IO、屏幕亮度方面去优化了 常规负载优化 CPU负载 GPU负载 性能优化都可以理解为是CPU负载、GPU负载的优化 当游戏锁60帧时，CPU开销控制在 10-12ms GPU开销控制在 6-8ms 当游戏锁30帧时，CPU开销控制在 18-20ms GPU开销控制在 8-10ms几乎是不会遇到温度墙的 即使你的开销超过个推荐数值，也要尽量控制不让GPU的负载超出太多，CPU可以适当放宽，更高的开销带来的发热量一般GPU比CPU大 非常规优化 网络与IO 发包频率 需要通过端口和IP区分哪些是真正意义上的网络通讯开销 频繁IO读写 一些网络游戏本身通讯量不高，或根本就是单机游戏，但由于使用第三方的广告平台或信息收集平台的SDK后，也会开启一些网络线程，并进行非常频繁且大量的数据通讯，这块带来的发热问题也不容小觑，需要额外关注有没有一些设置来调整这些SDK 显示亮度与FPS 现在大多数高端手机都以拥有高亮度的手机屏幕为追求，其实在绝大多数手机游戏运行时，完全没有必要开启最高亮度，甚至为了减少屏幕发热，需要在开启游戏后，将屏幕亮度控制在一定范围内。在一段时间待机的情况下，甚至要大幅度调低手机屏幕亮度以节省电量、减少屏幕与电池的发热量 针对手机游戏显示帧率的问题，一定要按需控制帧率，有些没有必要锁60帧的游戏类型，完全可以采用锁30帧的方式 在全屏UI或模态对话框覆盖屏幕时，可以将原来30帧的显示帧率调整为一半，将60帧的显示帧率调整为原来的1/4 甚至在待机状态，屏幕亮度调暗的情况下，可以调整到个位数的帧率，更激进一点的做法，可以同时调低显示分辨率。这一方式对于一些发热严重的手机及其有效 调整显示帧率不要通过Application.targetFrameRate来进行调整，而是通过Unity提供的OnDemandRendering接口的renderFrameInterval来调整，因为Application.targetFrameRate调整后会导致显示频率与输入频率一起下降，一些更新逻辑也会变慢，而OnDemandRendering接口只会调整显示频率，你的输入不会感觉到有任何延迟 三方库 Wwise 目前很多移动平台游戏都会选择Wwise作为音乐解决方案，这套库本身就很重，后台回开启多个长度线程进行解码与异步操作，并且该库在默认设置下并不会控制多音源混合个数，当混合个数较多时，开销呈指数增长，对CPU压力较大，建议将混合的音源个数控制在4个以内，基本上可以满足绝大多数的移动游戏了 CRIWARE 经常用到的处理视频的解决方案库 这是一个更恐怖的库，默认带CAk开头的线程都是它开启的，并且每个线程的开销都很高，而且一直很高，视频播放完负载也不会降低。一般情况下，同时只开启一个视频时，可能感受还好 总结 功耗和发热问题，不仅仅需要对游戏本身做常规优化，还要关注这些三方SDK，使用时，不要用无脑的默认设置进行集成，一定要看看有没有提供优化的设置或接口，否则这些三方库和SDK也会成为一个个耗电发热的小能手，最好分别做裸包与平台包的耗电量与发热测试 "},{"title":"性能优化(37)——渲染优化——Shader指令优化","date":"2022-11-19T04:15:43.000Z","url":"/2022/11/19/performanceOptimization-32/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Shader数据类型精度 Float(32bit)：位置与纹理坐标信息 Half(16bit)：纹理坐标与颜色信息 Fixed(11bit)：颜色信息。只针对一些老旧的CPU设计所保留，只在BuildIn管线下适用，SRP下已不支持 尽量使用内置函数 pow normalize dot inversesqrt … 超越函数 一些变量之间关系不能用有限次加、减、乘、除、乘方、开方运算表示的函数，在数学上称为超越函数。这些函数在芯片指令上实现都属于资源密集型函数，在一些低端设备上要慎用、少用，带来的指令开销会比较高 exp log sin、cos、tan… asin、acos、atan、atan2… sincos … 指令周期与阶段 一条指令从取指、译码、执行、存储等一系列过程称为一个指令周期，可以理解为图中的cycle 但某些简单指令与复杂指令的cycle周期并不一定一样长 由于现代GPU Core内核是SIMP为架构的，长度一致的指令cycle更有利于单指令多线程的并行计算 因此，为了避免浪费，GPU设计时又将cycle中设计成了多个阶段，也就是多个Phase 如果一条简单指令在一个Phase内可以完成，那么在一个cycle内可以合并多条简单指令成一个稍微复杂的指令，如MAD指令以及现在常在XCode中抓取看到的，具有更高精度的FMA指令 指令优化 mul + add =&gt; mad：mad指令就是一个乘法指令加上一个加法指令 (x - 0.5) * 1.5 ——&gt; x * 1.5 + (-0.75) 这样之前的一个减法指令和一个乘法指令会被优化成一个mad指令，指令周期也从两个cycle优化成一个cycle 除法 =&gt; 乘以倒数(rcp) (t.x * t.y + t.z) / t.x ——&gt; t.y + t.z * (1.0 / t.x) 对齐 float3 * float * float * float3 ——&gt; (float * float) * (float3 * float3) abs或neg指令输出 =&gt; 输入 abs(a.x * a.y) ——&gt; abs(a.x) * abs(a.y) -(a.x * a.y) ——&gt; -a.x * a.y saturate指令输入 =&gt; 输出 1.0 - saturate(a) ——&gt; saturate(1.0 - a) min或max =&gt; saturate(某些平台) max(x,0.0) = min(x,1.0) ——&gt; saturate(x) sqrt(x) =&gt; rcp(rsqrt(x)) :sqrt改成rsqrt的倒数 if0 =&gt; sign(x)：用sign指令代替含零的判断分支语句 if/else =&gt; step(x) lerp(a,b,step(cx,cy))：用step + lerp代替非零的判断分支语句 sin/cos/sincos &lt;&lt; asin/acos/atan/atan2/degrees/radians MUL =&gt; MAD-MAD-MAD向量乘法指令优化成多个mad指令 mul(v,m) =&gt; v.x * m[0] + v.y * m[1] + v.z * m[2] + v.w * m[3] mul(float4(v.xyz,1)) ——&gt; v.x * m[0] + v.y * m[1] + v.z * m[2] + m[3] v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3])) normalize/length/distance都包含一个dot，可以共享 length(a - b)与distance(a,b)可共享，但与distance(b,a)不共享 normalize(vec) =&gt; vec * rsqrt(dot(vec,vec)) 50 * normalize(vec) ——&gt; vec(50 * rsqrt(vec,vec)) 自表达式不共享指令 v = normalize(v) return v mul =&gt; mul24：在高版本的shader mode下，乘法指令也有专门用于向量前三个元素相乘的mul24指令进行优化 fma注重精度的mad texture.Load VS texure.Sample：texture.Load在(0,1)的寻址区间会比texure.Sample采样更高效。但Load(tc,offset)&gt;Sample(tc,offset) 其他 FS =&gt; VS 避免隐式类型转换，如vector4隐式转成vector3 Varying数据尽可能组织成向量形式而非标量形式，这样可能会减少一些寄存器的miss catch，而将像素阶段的shader中的逻辑尽可能转到顶点阶段处理，也是均衡vs与ps阶段的gpu负载的一个好手段 以上shader指令的优化有个印象就好，不同平台或shader mode的版本差异，可能编译以后的汇编指令条数也有所不同，要看实际汇编条数是否真的减少了，才能确定我们的写法是否能达到优化的效果，这需要在特定的平台上经过长时间的经验积累才能做到如此指令级的优化 其他指令优化 针对于分支或循环语句优化的命令 如果分支判断的两个分支语句足够简单，我们可以将分支语句展开两个分支同时处理，并选择一个正确结果，我们可以用UNITY_FLATTEN标记分支语句是否展开，用UNITY_BRANCH标记是否真分支需要动态判断 一般来说我们可以按照分支语句是否超过六个指令来判断是否展开，如果两个分支语句中指令都小于六个，可以进行展开；如果分支语句大于六个，并且判断结果大多数都走一个分支，那我们可以用UNITY_BRANCH进行标记；如果两个分支走得比较平均，并且两个分支复杂度相同的情况下，在Unity2022下，我们可以充分利用dynamic branch声明shader关键字做运行时动态分支处理 循环语句不展开，可以用UNITY_LOOP标记为真循环，如果需要展开，可以用UNITY_UNROLL标记 明确需要展开到第几层时，可以用UNITY_UNROLL(_x)带层数参数来标记 Unity Shader中可能导致Early-z失效的操作 Shader中开启了Alpha Test 像素着色时调用了Clip()或Discard指令 Shader中开启了Alpha Coverage功能 在光栅化后修改了像素深度 手动关闭了Shader中的Depth Test标记 Early-z失效的像素过多，带来的后果就是处理像素过多，导致渲染性能下降，因此做一些功能取舍的时候，这个指标是一个关键的参考点 某些平台慎用或推荐用某些内置功能 Alpha Test Color Mask sRGB硬件解压 是否使用Alpha Blend代替Alpha Test，或关闭Color Mask功能，都需要在真机上测试才知道，因此移动平台上优化的最大工作量是要考虑多平台、多硬件、多API的兼容，而且是优化手段的兼容 大多数平台目前都支持sRGB格式的硬件解码，所以建议纹理资源导入设置时，勾选使用sRGB格式 "},{"title":"性能优化(36)——Shader与托管内存优化","date":"2022-11-18T04:25:12.000Z","url":"/2022/11/18/performanceOptimization-31/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Shdaer的内存问题 引起Shader内存的主要原因是Shader的关键字过多，导致SHader的变体过多，打包时如果变体剔除做得不好的话，就会导致Shader的内存过高。因此做好Shader变体的剔除是控制Shader内存占用量的关键 变体剔除与变体收集 是为了让运行时Shader的内存占用更少，剔除掉不会被使用的Shader变体 变体收集是为了做Shader的WarmUp，目的是为了避免运行时Shader加载编译导致的性能问题 变体收集可以用来辅助变体剔除工作，可以作为不被剔除的Shader的参考 对于Shader变体非常多的情况下，做到变体完全剔除干净或变体完全收集完整是个很难做到的工作。这种情况下，我们只需要保证变体剔除尽量干净、收集尽量完整即可。中间一部分冗余占用的内存在可接受范围内时是可以被忽略的 查看具体Shader会产生多少个Shader变体 一般我们是通过Shader的Inspector面板来查看的 但由于平台不同，不同的平台或图形API需要切换到对应平台或API上才能统计正确。而且每个Shader都要做统计，一些Unity内置的Shader也难以统计。这样就有些麻烦了 这时我们可以通过打包后的Editor.log来查看Shader变体个数与Shader变体剔除的统计结果 在文件中搜索Compiling shader字段，这时会列出每个Shader的变体个数和实际打包到包里的变体个数 具体Shader在实际平台占用的内存还需要在移动设备上运行时通过Memory Profiler进行抓取查看 托管内存优化 具体会与用户脚本、开发者编码习惯直接相关 C#语言层面： Boxing Allocation装箱操作：指类型转换到引用类型的转换，会造成额外的内存开销。使用Lua等脚本语言做热更新逻辑的开发者，在封装交互接口时，尽量不要传递Unity引擎里定义的对象，尽量保证调用的函数接口传递或返回基础类型值对象 String字符串拼接：做字符串拼接应尽量使用StringBuilder进行 闭包分配：一般是指代码段中使用了代码段之外定义的变量，如匿名函数或Lambda表达式，当调用这一类代码段时，托管堆中会生成一个类来保存这些代码段中引用到的外部变量，会有额外的内存开销 避免使用Linq库写任何游戏内的代码：它们会生成大量托管堆上的垃圾内存 Unity相关代码调用 Unity中提供了很多NonAlloc函数（无托管内存开销的函数），与之对应的是有托管内存开销的函数 如：Physics.RayCastAll对应的无托管内存开销的函数是Physics.RayCastAllNonAlloc Unity下一些返回对象列表的函数都是有托管内存开销的。如： Unity.Object.FindObjectsOfType UnityEngine.Component.GetComponentsInParent UnityEngine.Component.GetComponentsInChild等 一些Unity类成员变量访问的方式：如直接通过”.”调用的成员变量，应尽量采用”.Get”的方式去调用。如： UnityEngine.Mesh.vertices =&gt; UnityEngine.Mesh.GetVertices, UnityEngine.Mesh.uv =&gt; UnityEngine.Mesh.GetUV, UnityEngine.Renderer.sharedMaterials =&gt; UnityEngine.Renderer.GetSharedMaterials, Unity.Input.touches =&gt; Unity.Input.GetTouches等 无论是C#还是Unity相关的代码调用，如果发生在循环或者每帧更新的函数里，造成的托管内存开销会更大 我们尽量还需要注意，不要在循环或每帧更新的逻辑中反复去Instance对象，应尽量在初始化时利用内存池预先分配好，避免在运行过程中的GC开销 当你发现你的游戏每帧GC开销变化过大时，可以开启BuildSetting-Player中的增量GC选项，它可以将一帧中的GCCollect调用分摊到多帧进行，可以有效地平滑你的游戏帧率 BuildSetting中的关于程序集优化的配置：在Optimization标签下，默认会勾选Strip Engine Code选项，开启这个选项后，如果backend是IL2CPP的情况下，Unity会删除项目不使用的Unity引擎的代码，强烈建议开启，不仅会对包体大小有优化，对应用程序内存的占用也可以减小 这个选项下面的Managed Stripping Level，可以根据包体和内存的需求进行配置，它会根据不同的选项自动删除托管dll中的不使用的代码，同样也可以减小包体的同时减少内存的占用，不过当设置的级别过高时会导致误删某些C#接口导致编译出错，这时你可以为误删除的接口打上Preserve的属性标签以防止这个接口被删除。也可以使用linker.xml文件进行更详细的配置，不过这个选项只针对需要极限优化的项目，如果嫌配置麻烦，默认选项就好 "},{"title":"Java笔记(1)","date":"2022-11-16T14:14:15.000Z","url":"/2022/11/16/JavaStudy-1/","tags":[["Java笔记","/tags/Java%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"&nbsp; 常用转义字符 \\t ：一个制表位，实现对齐的功能 \\n ：换行符 \\ ：一个\\ \\“ ：一个” \\‘ ：一个’ \\r ：一个回车 注释 单行注释 多行注释 文档注释(类、方法) javadoc解析 javadoc标签：author、version、link等 "},{"title":"性能优化(35)——项目设置与内存优化","date":"2022-10-29T04:49:14.000Z","url":"/2022/10/29/performanceOptimization-30/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Texture2D纹理资源类型进一步优化 当场景中所有使用的纹理都开启了MipMap模式，这样我们可以通过Quality Setting中的Texture Quality选项来强制使用某一级别的MipMap Level Texture进行渲染，这样实际被加载到显存中的纹理，只有这一级Mipmap及其以下级别的纹理，占用的显存也会相对更少 目前Unity只提供第0、1、2、3级的Mipmap设置，实际对应原尺寸、1/2、大小、1/4大小、1/8大小的纹理 但这种方式需要在纹理加载前确定设置，因此每次修改想要设置生效，只有重启游戏才能生效 比较适合高中低端机型比较明确的情况 我们还可以利用Unity提供的Mipmap Streaming功能来做运行时动态调整 除需要对应纹理开启Mipmap导入设置的同时，还需要将纹理导入设置的Streaming Mipmap功能选项打开，同时开启Quality Settings中的Texture Streaming功能选项 该功能会强制Unity仅加载渲染当前相机所需级别的Mipmap层级，使用少量CPU资源来节省大量GPU上的内存 和Texture Quality功能类似，但这个功能是运行时进行的， Unity提供了该功能一系列API，让你可以为应用程序的纹理设置总内存限制，这样Unity会自动降低纹理的Mip级别，来保证纹理内存开销在预算范围内 不过这个功能需要开发者非常了解其实现原理，如果只是傻瓜式开启，往往达不到优化效果，甚至设置不合理会导致画面损失较大，甚至负优化的产生 Mipmap Streaming的参数设置 Memory Budget：为加载纹理的总内存预算，如果大于该预算时，后续加载的纹理会采用更低级别的Mip Level。这里如果内存预算设置的太高，则起不到太多内存节省优化的作用，甚至可能造成浪费；如果设置过低，画面损失可能会比较大 Renderers Per Frame：为每帧CPU为Mipmap Streaming功能要处理多少个网格渲染器，虽然降低该值会减少CPU处理开销，但可能会增加加载Mipmap的延迟开销，因此需要测试平衡该值的设置 Max Level Reduction：代表当纹理内存达到内存预算上限时，最大可以跳过加载的Mipmap级别数，同样，设置低了会造成Mipmap加载延迟开销，设置高了会造成画面损失较大 Max IO Requests：是用于加载Mipmap Streaming流的最大IO请求数，如果设置得足够高，可以防止异步纹理上传阻塞。但某些系统会本身设有IO请求上限；同时设置太大，本身也会有系统的开销 另外，关于相机的Mipmap Streaming设置，可以通过Streaming Controller脚本为每个相机设置不同的Mipmap级别的偏移 通过给每一个纹理导入设置Mipmap Streaming优先级别，可以强制在预算内存范围内优先加载哪些纹理，以弥补整体设置激进的情况下造成的视觉损失 总之，Mipmap Streaming功能几乎所有参数设置是一套多元多次多项式，随着项目规模、场景复杂度、摄像机角度变化、Mipmap纹理个数等等因素的不同，很难找到一个最优化的设置 最让人难受的是，在SRP下，没有像Build-In管线下的Mipmap调试模式，这样就更难找到符合你的项目的一套最优化参数 如果在SRP下使用该功能，建议为这个功能开发一套调试UI，将所有参数变量暴露到UI上，并可动态调整，然后去为你的项目每一个场景做测试调整，在视觉可接受的前提下找到一套正优化的参数，不要期望找到最优解，可以根据你具体优化的目的找到一套相对优化解就可以了 "},{"title":"性能优化(34)——内存优化(3)——内存指标术语与进程内存介绍","date":"2022-10-29T03:55:03.000Z","url":"/2022/10/29/performanceOptimization-29/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 几乎在所有操作系统上，虚拟内存与物理内存都是以Page来组织的 Page是操作系统管理内存的最小基础单元，通常为4k大小，但在不同的操作系统和平台上可能有不同，比如在比较新的IOS或Mac操作系统上是16k大小 一般，电脑中的CPU会有一个内存管理单元，MMU，它会维护一张Page的表，并将虚拟地址映射到物理内存地址上。当用户访问虚拟地址时，会自动被MMU转换为物理地址。但当CPU访问虚拟地址并没有找到映射的物理内存地址时，CPU会触发Page fault中断当前程序执行，然后再分配一块干净的物理内存，并从磁盘中加载所需的一页数据到该物理地址，同时更新列表并继续执行程序 当一个进程向系统申请内存时，系统并不会返回物理内存地址，而是返回一个虚拟内存地址，仅当CPU需要访问该虚拟内存地址时，系统才会分配并映射到物理内存上 每个Page可能有不同的状态，用来描述该内存页处理的不同事务状态 Used代表Page正在被进程使用，而内存页也已经被映射到了物理内存中 Free代表该Page页可用，并且该内存页还没有被映射到物理内存中 Cache状态代表该页被操作系统用于缓存的可用内存，虽然内存页已经被映射到物理内存中，但该页可能近期没有被访问 如果Free Page数量低于一个阈值时，操作系统会从Cache的页中去获取内存，并将Cache页上的数据交换到磁盘，然后对Cache的页进行清理，并将其标记为Free Page 在内存管理的更高级别上，操作系统的虚拟内存还会将Page组织成区域。可能在不同的操作系统中使用不同的名称来定义这个概念，这里统称为Region，它是一块共享内存状态和保护级别的连续地址空间。它可以由具有不同的页面状态的多个Page组成 当然Region也有不同的状态： Resident：代表其中的配置页已经在物理内存中 Dirty：代表配置已修改，但未写入磁盘 Wired：代表永远不会交换到辅助存储的固定配置段 Committed：代表已分配的内存区域，其地址不能被其他分配使用，是由RAM磁盘上的分页文件或其他资源来支持的，访问权限由内存的保护级别控制 Reserved：该状态的Region保留地址空间，供将来使用，地址不会被其他分配使用，也不可访问，如果尝试从Reserved的内存读写，都会导致访问冲突异常，并且它没有与之关联的物理存储支持 Free：是空闲内存区，既不会Committed，也不会Reserved，并且进程无法访问，同样任何尝试读写Free状态的Region也会导致访问冲突异常 Region的类型： Anonymous：是匿名的，这类Region上的内存页，与文件系统上的文件并没有关联。例如，C++使用malloc的任何分配，或mono上的分配都是匿名的 Mapped：映射类型，这类Region包含的内存页，是以文件系统设备节点关联的，文件与内存将做直接映射 一个进程的内存结构 Committed Memory 是一个进程分配虚拟内存的总量 从纵向看，包括物理内存、Mapped Files、Swapped Files、Compressed Memory四部分 从横向看，包括当前进程私有占用的内存，和与其他进程共享的内存 Resident Memory 已经被映射到虚拟内存中的物理内存 同样包括当前进程占用的内存，和与其他进程共享的内存 其中存在一些非代码执行的开销，如系统或应用的二进制加载所占用的内存 进程的内存结构（进一步细分） 可分为： VSS：即总共Commit提交的Regions内存总和 RSS：进程可访问的Resident常驻内存总和 PSS：当前内存常驻内存与其他进程共享的Resident内存总和 USS：为当前进程私有的Resident内存总和 Unity下提供的Memory Profiler工具，总体内存是对Commited Memory即VSS进行衡量的，而并不涉及是否为Resident Memory Windows平台下，Windows任务管理器中的Memory指标是针对于USS来衡量的 Mac与IOS下，XCode显示的内存衡量的是RSS加上压缩后的内存交换页的大小 如果大于此经验值，也不一定完全不行。游戏类型不同，各类资源占用也会有所差异 另外，System.XXX总和这一项的内存开销基本来自于用户的配置数据表，与C#层的基础类型变量的定义。一些开发者习惯把所有配置数据全部缓存进来，会导致此项内存开销过高，尤其是一些纯文本数据，如果真的需要，也建议采用二进制方式分级缓存读取 还有其他各类对象单选这条，是指一些C#层的对象，主要会是一些Component与GameObject派生出来的对象，我们不仅需要关注这些对象所占用的内存大小，还需要关注对象个数 "},{"title":"性能优化(33)——内存优化(2)——NATIVE内存分配器详解","date":"2022-10-09T01:56:57.000Z","url":"/2022/10/09/performanceOptimization-28/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 我们都知道，Unity底层是C++实现的，游戏引擎都不会直接通过malloc与new直接分配内存，至少都要在其上封装一层来做内存管理、统计与检查等工作 Unity引擎中，C++层会根据内存用途不同，抽象成不同的allocator进行内存分配，通过不同的Memory Lable标签与OwnerShape的设置进行标记与追踪，通过MemoryManager进行整体的管理 这几块都在Unity源码中，购买过源码的可以在源码中看，没有购买过的，只有Allocator可以在Unity2021以上版本中的ProjectSetting-Memory Setting中窥得一些端倪 Unity Native层会根据分配算法的不同以及用途的不同定义非常多类型的内存分配器。今天，我们只需要关注MemorySetting中，我们可以自定义并且比较典型的几类 分配器Allocator的分类 Main Allocators：绝大多数内存分配使用的分配器，包括主线程、渲染资源相关、文件cache、typetree等不同用途下的分配器 Fast Per Thread Temporary Allocators：线程上使用的临时分配器，包括各工作线程的栈分配器，比如音乐、渲染、预加载、烘焙等工作线程上的分配器 Fast Thread Shared Temporary Allocators：线程间共享的临时分配器 这四种大的分类与其中的小类，都是用途抽象意义上的分配器，在Unity引擎代码中并没有一一对应的分配器的类，而在Unity代码中则是根据分配算法分类的分配器 包括Unity默认分配器、桶分配器、动态堆分配器、双线程分配器、线程本地存储分配器、栈分配器、线程安全线性分配器以及用于各个平台特性的分配器与调试分配器太多太多 它们与按用途分配的分配器是一对多的关系。也就是按用途分类的分配器底层都是以按算法分类的分配器实现的 它们只是底层分配器抽象的一层皮，而MemorySetting自定义设置中既是把这层皮暴露到编辑器中了。我们需要了解它们具体对应关系才能真正了解如何下手去自定义内存分配器 以下图表大致描述了底层按算法分类的几大类分配器，与按用途划分的分配器的关系 主要的底层分配器桶分配器 在Unity Player下，默认的粒度大小为16个字节，用于分配16、32、48、64等等字节的内存 该分配器默认分配保留1个内存块Block，每个块会被划分为16kb的子段，并且这个大小不可配置。如果需要调整Block块，则Block块只能增长，并且需要是固定16kb大小的整数倍 这个分配器的粒度大小与Bucket的个数是需要根据游戏内情况来配置的，默认粒度是16个字节，默认的Bucket是8个，这样在Release版Player下，1个16kb子段下最多可以容纳1024个Bucket；而如果将Bucket的粒度调整为64个字节，则1个子段只能容下256个了 动态堆分配器 TLSF算法：你可以理解为——它是两层链表管理的内存块，第一层以2的幂次方划分，当第一层的内存块分配有剩余时，引入第二层链表，将第一层中使用的内存块剩余部分用更精细的粒度进行划分。在保证分配效率的同时提高内存利用率 双线程分配器 两个线程上使用的分配器TLS Stack Allocator 如果发生溢出回退情况，则会回退到Thread Safe Linear Allocator Thread Safe Linear Allocator 如果发生了溢出，需要判断该溢出是否发生在资源加载期，还是正常的帧渲染期 如果加载期溢出，帧渲染期平稳，我们可以不用理会；如果正常的帧渲染期溢出数量增加，我们需要调高该Allocator的Block Size大小 不过如果你有足够的内存预算，无论是在加载期还是在正常帧渲染期发生溢出的情况下你都可以调高 Unity2021版本上已经有文档可以学习了 2021以下版本想要自定义内存分配器，只能通过修改源码的方式进行了 "},{"title":"性能优化(32)——内存优化(1)——Unity中的内存概述与工具方法","date":"2022-09-30T02:04:43.000Z","url":"/2022/09/30/performanceOptimization-27/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Unity引擎中的内存 托管内存：包括托管堆内存、脚本堆栈内存与虚拟机内存三部分。其中托管堆内存是优化的主要部分。托管内存使用方便，但释放与内存分配方式不可预期。另外，Unity使用的是保守的贝姆垃圾回收器(Boehm–Demers–Weiser garbage collector)，在内存的管理与分配上并不会太激进，因此一些使用不当会造成内存的浪费，也可能会有性能的问题 C#非托管内存：是指在C#层不使用垃圾回收器管理的内存部分，它允许访问Native内存层，可以进行内存分配的微调，一般在C#下使用Unity Collection名字空间与包结合使用，也是将来使用DOTS程序加速准备的数据结构访问的内存.所以如果你的项目刚立项，如果使用数据结构，不建议使用System下Collection的数据结构，而推荐使用Unity Collection下的数据结构进行开发 除红色Unity中的内存之外，Unity的应用程序还包括青色部分渲染资源占用的显存，如果是移动平台，该显存是与内存共享的；还包括蓝色部分应用程序框架所需要的内存、一些第三方库占用的内存以及操作系统为应用分配的内存。蓝色部分是不能通过Unity引擎提供的工具获取的，不过我们可以借助一些操作系统工具、编译工具或第三方工具进行抓取 Unity引擎提供的内存方面的工具Unity提供的 Unity Profiler Unity Profiler下的Memory标签，这里列举了Unity当下内存使用的追踪状态，包括各类内存的分配与使用情况，以及当前Unity下分配的对象与资源占用的内存情况 注意：Unity2021以后的版本，Profiler不再提供对象抓取快照功能了，而是使用Memory Profiler直接抓取内存快照了 此外，Profiler的Menory标签下默认提供的指标并不全，如果希望得到更详细的信息，可以通过添加自定义Profiler Modules加入更多的Memory Counter指标，也可以扩展Profiler Modules，通过对应的系统接口，提供更详细的内存指标加载到Profiler中 Unity Memory Profiler 可以通过它抓取内存快照，也可以对比两个内存快照下，Unity对象与资源的差异 通过Tree Map查看内存分配的视图 通过Object and Allocations标签查看具体对象内存快照，并可以通过链接直接找到原工程中对应的资源或对象 通过Fragmentation标签，可以查看内存片段。Unity2022以后，Memory Profiler变得更加简洁易用了，针对Native内存，甚至可以查看到具体是分配到哪个Allocate中的 内存相关设置 自Unity2021后，Unity开放了针对于Native层的内存分配自定义设置功能，用户可以针对自己项目的特定，自定义相关内存的Allocate分配块大小.大家现在可以在权衡时间与空间维度上的性能指标做更精准的设置了 此外，与内存相关的设置还有一些在工程设置中和图像设置中 UPR中的内存快照与对象快照功能 主要是针对于移动设备，当你使用UPR做性能调试时会经常用到 它可以脱离Unity编辑器，在运行时抓取内存信息与对象分配信息，并可以做到多帧对比比较 具体使用方法都是通过快捷键完成的，可以参阅UPR手册 Unity外的工具 Mac或IOS上可以选择XCode提供的Instruments下的Allocations工具 安卓上可以使用安卓相关的系统命令，或安卓Studio的Profiler工具，或者一些第三方工具，但一般不太好用 一般我们还是先在IOS上进行内存优化 Allocations工具： 使用profiling运行XCode工程，当编译完成后，在profiling模板界面选择Allocations工具，并启动录制，也可以直接启用Instruments工具 直接选择Allocations工具，并挂载手机上要测试的项目的进程，你也可以长按录制功能键修改录制选项，一般情况下需要在启动前选择下VM Tracker标签，选择完成后，XCode下会出现一个Snapshots按钮，在其中勾选Automatic Snapshotting选项，只有勾选了这个选项，才能看到VM Tracker下的信息 点击录制按钮拉起我们的应用程序，这时会看到Allocations与VM Tracker中会有曲线变化，这代表我们正在录制中 我们可以多测试下游戏中各个场景间的切换，观察曲线变化 完成后可以选择停止选项，这时录制信息并不会丢失，但其信息内容会非常多，这里只挑我们最需要关注的指标进行说明： VM Tracker下的Dirty Size、Swapped Size、Resident Size Resident Size代表使用的物理内存量 Swapped Size代表不活跃的内存，可以被交换到磁盘上的大小。可以理解为可卸载的大小。在IOS中，只有非Dirty的内存页才可以被交换或卸载 Dirty Size代表物理内存中不能被复用或者被卸载的内存块。这个数值非常重要，一旦超过一定大小，IOS程序就会自动退出，这个大小在1G内存的手机上大概是700MB，2G内存的手机上大概是1.4G，这个数值直接关乎我们的应用程序在长期运行时会不会崩溃，所以需要关注它的峰值是否超过警戒线，并且有没有下降的过程 接下来我们可以将Statistics标签切换成Call Trees，并在下面CallTree按钮中选择按线程分类，这样会方便我们查看具体那些线程做了哪些分配情况。如果发现线程堆栈是16进制地址，这可能是苹果系统或XCode版本造成的，只需要点击Date Mining中的Restore即可恢复 完成这些后，我们可以看到渲染线程、主线程、Unity的加载线程的内存排在前三，可以在时间轴框选我们需要采样、查看内存分配情况的时间段来进一步看这个时间段各个线程的分配情况 "},{"title":"性能优化(31)——级联阴影优化","date":"2022-09-28T02:15:34.000Z","url":"/2022/09/28/performanceOptimization-26/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 记得关闭地形投影 既然我们做场景LOD时，远处的模型被替换成低模，动画看上去也不会动了，那么阴影贴图渲染其实每帧变化并不大，也会随着级联阴影层级的提高变化越来越小 那么我们有没有办法在远距离的级联阴影级别下，可以不用对每个物体阴影做重新绘制呢 我们应该可以想象的，如果将阴影贴图进行cache缓存，并对级联阴影的每个级别的阴影贴图块，按不同的刷新率去更新，这样就可以降低每帧投影体绘制的次数了。也就是将LOD思想应用到了级联阴影上 首先想到的还是从URP源码入手 在URP下，主光源投影是通过MainLightShadowCasterPass.cs完成的，我们只需将其拷贝一份出来，并重新命名为MainLightShadowCasterCachedPass.cs，并将对应的Pass类名修改为MainLightShadowCasterCachedPass，同时修改UniversalRenderer.cs文件，将创建MainLightShadowCasterPass的地方替换成为MainLightShadowCasterPass对象 接下来看对MainLightShadowCasterPass做哪些修改 首先，我们既然要缓存生成的Shadowmap，那么我们的级联阴影的Texture创建就不能每帧创建了。我们需要移除OnCameraCleanup函数下的MainLightShadowmapTexture的释放逻辑，同时添加一个Cleanup接口，将其释放逻辑放到UniversalRenderer下的MainLightShadowCasterPass的释放逻辑 这样就变相延长了MainLightShadowmapTexture的资源生命周期 同时修改Setup函数下的MainLightShadowmapTexture创建逻辑，只有这个对象为空，或者Shadowmap大小发生改变时，才重新创建 同时添加一个判断是否为第一帧的bool变量，方便后面只处理创建后第一帧逻辑使用 然后需要添加一个针对于Shadowmap的更新数组 这里的1，2，4，8分别对应级联阴影的第1，2，3，4四个级别 这个数组有几个元素就代表了做几帧的更新循环 如：这里创建了第一帧更新是第一个级别与第三个级别的级联阴影块；第二帧更新是第一个级别与第四个级别的阴影块；第三帧更新的是第二个级别与第四个级别的阴影块。相当于每3帧更新2次第一个级别的级联阴影块，更新1次第二个级别的级联阴影块。这样就变相的相当于第一个级别的渲染频率降低到用来的2/3，而第二个级别的渲染降低到原来的1/3 同时需要定义一个int变量，用来记录当前总共进行了多少帧，方便取模后，按3帧一个循环来更新阴影贴图 我们还需要移除Configure中的ConfigureClear逻辑，这样就不需要每帧clear整体的Shadowmap了。若远处的级联阴影在远距离级别上会出现闪烁，就是没有移除该逻辑的后果 这些都准备好后，就可以修改阴影的渲染逻辑了 将RendererMainLightCascadeShadowmap中的每帧渲染逻辑替换为按更新数组3帧一循环的渲染逻辑，同时将ShadowUtils、RenderShadowSlice替换成我们自己写的RenderShadowSlice逻辑，主要是控制Shadowmap中不同级别阴影块的单独绘制，而不是更新整个Shadowmap了 同时你也可以修改SetupMainLightShadowReceiverConstants中的级联阴影各个级别矩阵的更新频率，降低一点CPU开销。不过不修改也没有关系，差异并不大 到此，按级联阴影的级别，通过更新频率控制每个阴影块渲染的优化的代码修改基本上完成了 但到我们捎入到手机上运行会出现崩溃，主要会发生在Matal的SetScissorRect函数里，其原因是MainLightShadowCasterCache的Path默认设置了NativevRenderPass导致生成的Shadowmap的临时RenderTarget的LoadAction与StoreAction都是DontCare，不做存储与加载操作。但由于我们的优化是跨帧修改了Shadowmap，因此需要Load与Store操作。这里最简单的修改方式就是将MainLightShadowCasterCache的Path不使用NativeRenderPass，将useNativeRenderPass变量设置为false "},{"title":"性能优化(30)——Terrain地形优化","date":"2022-09-27T02:02:45.000Z","url":"/2022/09/27/performanceOptimization-25/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; Unity的地形工具在移动端的效率不高，尤其是Terrain Shader不够轻量 一般都是用地形Mesh替代它，最好的方式是自己写一套地形烘焙的工具，根据Terrain Date将Mesh信息与混合后的地形纹理烘焙出来，并通过Prefab生成地形块 如资源商店Terrain To Mesh 2021，但它还有一些缺点： 它烘焙使用的Sprite Shader并不支持SRP Batcher，主要是太多的材质属性没有定义到const buffer中；而且由于Shader使用大量关键字来定义材质属性，导致改起来很麻烦 它的地形分块并不能对应多张地表diffuse map，这会导致如果原地形较大的情况下，一张diffuse map即使再大的分辨率，清晰度也是不够的，所以还是要用Sprite Shader来做，这就导致地表Mesh的Shader还是不够简单，纹理采样开销并不比Unity Terrain方式轻多少 "},{"title":"性能优化(27、28、29)——渲染管线精简与优化","date":"2022-09-25T06:24:15.000Z","url":"/2022/09/25/performanceOptimization-24/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Shader方面 在URP延时管线下，所有Unlit类型的对象都会被强制使用前向渲染管线渲染，所以这些对象不会有Gbuffer阶段，如果后续还需要使用Normal与Depth信息，只能通过Prepass的方式获取了 ASE生成的shader的指令集精度过高，导致渲染性能下降。我们可以利用half去替代一些float变量以提高渲染效率，这里有个原则： 如果变量是表示位置与空间信息的，不要用half去替换 如果变量是表示颜色与UV信息的，可以用half去替换 ASE生成的Shader无法符合Native RenderPass下的正确渲染表现 ASE生成的Shader并不匹配impostors插件的某些规则 URP中的Settings 强烈建议使用URP做项目的时候不要在URP Render Pipeline Asset中开启这两个Pass： 如果真的需要这两个Pass，可以选择在对应需要的Camera相机上对起进行复写设置。这样做的好处是，可以将两个Pass的生命周期与特定需要这些效果的相机进行绑定，并可以通过脚本在运行时控制其开启与关闭，这样在某些不需要的场景或相机上可以剔除掉这两个Pass，以节省GPG负载开销 "},{"title":"性能优化(26)——遮挡剔除与灯光剔除","date":"2022-09-25T05:55:36.000Z","url":"/2022/09/25/performanceOptimization-23/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"（不全） 地形较平坦时，地形对象上的投影体属性可以关闭.更多的是接受其他物体在地形上的投影，而不是自投影 对多实时投影的点光源的剔除优化： SRP下的Light Layers功能来做光影剔除 通过脚本逻辑控制光影剔除 通过脚本判断灯光与摄像机的距离来控制灯光组件的开启/关闭 同时控制同一室内场景中只有一盏点光源做室内区域投影的主光源 会有一定的CPU开销，当CPU是性能瓶颈的时候，这种方法就不太适合了 项目设置中Quality标签下对渲染管线设置 主光源依旧采用4096阴影贴图大小，以保证室外的阴影质量 对于室外的额外灯光，可调整每个对象最多能接受几盏灯光的影响(Per Object Limit) 额外光源投影的Shadow Atlas Resolution可调小到2048，因为室内距离较小，稍微调低了阴影贴图的Atlas与Shadow Resolution Tiers并不影响太大的视觉表现 由于所有开启额外灯光投影都会被打到同一个Shadow Atlas中，合适的Shadow Atlas Resolution与Shadow Resolution Tiers的设置才能保障视觉表现与是否所有额外灯光投影都能在同一张Shadow Atlas中容得下，如果容不下会出现以下警告提示 这种情况下一定会有额外光源的投影没有被显示，可能造成视觉上的错误。这时我们就要重新调整Atlas与Tiers的尺寸以进行修正 "},{"title":"性能优化(25)——中景简化与LOD策略","date":"2022-09-22T06:22:45.000Z","url":"/2022/09/22/performanceOptimization-22/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 传统的远景、中景、近景的概念 是指视距上的划分 远景：视距较远。主要用于表现一些开阔景物，为了渲染总体气氛和空间感，配合景深的表现可以让画面层次感更丰富，增加整体的意境。因此远景渲染我们不需要做具体的细节表现 中景：是指画面视觉中心的部分。一般用于进一步烘托整体场景气氛，需要一定的视觉和细节表现，但不需要过分强调，更多的是通过材质的颜色、质地、大范围的光影明暗来呈现 近景：是视距最近的画面部分。一般突出表现在具体某个物体或角色上，需要突出表现材质的细节，比如凹凸、光影细节、反射、折射、透视等高级效果，并且通过近景占屏幕比例多少，来与中景、远景形成更好的透视感 随着摄像机的移动，可能定义会出现一些重叠，近景的定义会更宽泛 如果对于需要在远景、中景、近景都需要出现的物体，可以将其LOD分为4级 0 —— 近景 1 —— 中景 2 —— 远景 3 —— 剔除 只需要出现在近景和中景中的物体，可以设置LOD为3级，2级为剔除 只需要在近景出现的物体，可以设置为2级，0级为近景，1级为简化模型或剔除 一般情况下，LOD级别设置最好不要超过5级 5级情况下 0 —— 原始模型 1 —— 1级简化模型 2 —— 2级简化模型 3 —— 替代体 4 —— 剔除 如果不需要使用替代体技术的话，我们可以选择不超过4级的LOD设置 减小阴影绘制阶段的压力：对场景中一些不必要的LOD级别上的模型不显示投影，只在LOD0级别原始模型下显示投影，其他LOD层级下的模型不显示投影 还有一些静态光照下的对象，已经在阴影体内了，也不需要渲染投影，毕竟还可以通过SSAO来显示接触面的暗部 替代体方案 首先，替代体方案不是没有开销的 虽然替代体方案比较适合第一视角，并且摄像机变化较慢的场景类型 但是选择目前Unity商店中任何一个插件实现，都必须要做一些资源和Shader上的调整，并且会带来一些未来插件更新的风险 因此该方案先搁置 毕竟优化是一个迭代的过程，先把一些风险小、开发工作不高，但收益大的优化方案优先来做。如果将常规手段用完后，性能还不能达到要求的，再上替代体方案 LOD Bias 这个参数主要是为了多平台LOD设置分级而使用的 值正好是1时，为工程内真实的设置 例： LOD0：100% —— 60% LOD1：60% —— 10% Culled：10% 当LOD Bias为0.7时， LOD0：100% —— 42% LOD1：42% —— 7% Culled：7% 当LOD Bias为2时， LOD0：100% —— 100% LOD1：100% —— 20% Culled：20% 也就是向更多的细节进行适配 "},{"title":"性能优化(24)——远景简化","date":"2022-09-17T03:09:09.000Z","url":"/2022/09/17/performanceOptimization-21/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"远景简化 一般情况下，我们通过传送就能走到的远景，一般都会选用模型；而不能走到的远景，一般都是使用天空盒完成的 做法 只需将场景中除远景外的对象先隐藏 然后在场景中添加一个反射探针烘焙Cubemap即可 注意要选择反射探针的类型为Baked，当然Custom也可以，选择后需要开启Static选项中的Reflection Probe Static选项 之后取消Windows-Rendering-Lighting下面的Auto Generate的复选框 这时会发现添加的反射探针Inspector面板中会出现Bake按钮 接下来要根据实际远景裁剪距离设置裁剪平面 同时可以提高渲染分辨率，这个大小与实际模型表现的质量最为接近 如果不需要HDR的Cube Map还可以取消HDR选项，这样烘焙出的非HDR的PNG格式Cubemap会更小 之后点击烘焙按钮，会烘焙出对应的Cubemap 接下来，创建天空盒材质 首先创建一个新材质(Material)，选择它的Shader为Skybox/Cubemapm，并在贴图中指定刚刚生成的Cubemap 之后我们需要替换Windows-Rendering-Lighting中的Environment标签下的天空盒材质为我们刚才创建的材质 这样就将远景模型替换成天空盒的简化做好了 我们可以调整天空盒材质的曝光系数开控制远景天空盒的明暗，来模拟天空的变化；也可以通过旋转系数控制远景贴图的旋转显示角度 另外：Unity下生成Cubemap并不是只有反射探针这一种方式，还有两种常用方式： 通过Assets-Create-Legacy-Cubemap来创建Cubemap资源。 这种格式未来Unity可能不太支持了 还有一种是利用Camera.RenderToCubemap接口来进行创建 可通过官方文档学习 官方文档给出了三种案例的代码，如果你需要通过脚本创建，或者在运行时创建，设置是创建stereo Cubemap都可以 "},{"title":"性能优化(23)——Unity中的Batching(下)","date":"2022-09-12T08:44:58.000Z","url":"/2022/09/12/performanceOptimization-20/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Batching的使用限制Static Batching限制（较少） 额外内存开销 64000个顶点限制：Unity下，一旦静态合批后的对象网格顶点数超过64000个，就会自动开启下一个静态合批 可能影响Culling剔除的结果 Dynamic Batching限制 合批后的对象不能超过900个顶点属性 顶点属性，而不是900个顶点。如：你的基础顶点有位置、颜色、法线、UV坐标四个属性时，那么最大的顶点数就不超过900/4=225个顶点 除了渲染阴影对象外，相同材质，不同材质实例也不能合并 就是说，即使你复制了两个一模一样的材质赋给两个对象，即使材质属性内容一模一样，也不能进行动态合批 具有光照贴图的游戏对象如果有附加渲染器参数时，如果需要动态合批这些对象，它们必须指向相同的光照贴图位置 也就是要有相同的光照贴图UV才能进行动态合批 这个要求非常苛刻，所以大部分具有光照贴图的游戏对象很难做到动态合批 着色器具有多Pass的材质对象无法动态合批 受多个光照影响的游戏对象，即使满足动态合批条件合批后，也只会受到一个光源影响 延迟渲染下不支持动态合批 CPU开销可能会增大，需要测试开启使用 GPU Instancing限制 需要图形API版本与Shader版本的支持 移动设备上需要OpenGL es3.0以上版本的支持 GPU Instancing与SRPBatcher不兼容 不同绘制API的参数与绘制个数不同 渲染顶点数较少的网格时，效率可能会较差（测试使用） SRP Batching限制 需要图形API对Const Buffer的支持 必须是SRP渲染管线 Shader必须是compatible时才能生效 粒子对象不能做SRP Batching合批 使用MaterialPropertyBlocks的游戏对象不能合批 合批失败的原因汇总（Unity2022版本上最全最新） 这些原因一般都会显示在Frame Debug中抓取的管线信息，如下图所示的位置 补充： 1.由于要走多个灯光Pass所以不能合批 2.即使材质的属性数值完全相同也不行 3.这里的不能合批是指在Shadow Pass中的合批 2.对象不能进行GPU Instancing合批 4.这种情况主要是由于静态批次合并的网格顶点数达到64000时，即使两个对象一样，距离也临近，但还是会拆到两个批次中去 2.这种情况一般发生在粒子对象定义了Additional Vertex Stream时 5.因为这种情况它也没有对象可以合 4.也就是一个SRP Batcher Const Buffer内容达到最大时，会进行Flush操作，这时会自动开启下一个SRP Batcher 6.节点材质需要改变渲染设备状态时，会切换SRP Batcher。因为所有渲染器状态切换都会进行一个新的Set Pass Call 7.因为这时前面也没有任何对象进行渲染 8.这种情况一般是你修改了管线中默认的顶点数据结构，两个不同顶点结构的网格对象是不能进行合批的 "},{"title":"性能优化(22)——Unity中的Batching(上)","date":"2022-09-12T07:13:28.000Z","url":"/2022/09/12/performanceOptimization-19/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"Unity中的合批 类比将桃子装卸发货的过程。其本质就是按需求组织数据从CPU发给GPU的过程，这些数据包括网格、纹理、Shader变量、材质属性等等。那么这些数据怎么组织、以什么结构组织、以什么频率发送、每次发送多少就是我们Batching要研究的问题了 哪些内容需要Batchaing 广义上讲： 资源Batching(Mesh、Texture、Shader参数、材质属性)：这些资源的合批是做后续某些Batching优化的前提 Draw call Batching(Static Batching、Dynamic Batching)：主要是为了降低GPU的DP操作，能更少地调用绘制命令接口，Unity在这里为我们提供了Static Batching与Dynamic Batching功能 GPU Instancing(直接渲染、间接渲染、程序化间接渲染)：这也是一种绘制优化的手段，用于绘制多个副本网格对象。Unity提供了直接渲染、间接渲染、程序化间接渲染的三种方法接口 Set Pass call Batching(SRP Batching)：之前Draw call Batching是为了减少渲染操作调用次数，而Set Pass call Batching是为了减少渲染状态切换的次数。Unity下为我们提供了减少Set Pass call次数的SRP Batching的功能 资源的Batching Mesh： 我们可以将临近且不移动的网格对象通过Mesh.CombineMesh合并到一起，合并后用一次网格的渲染调用代替每个网格的渲染调用。但这种方案也有一定的弊端，一旦合并的网格对象较大时，可能造成摄像机剔除不掉的问题以及OverDraw的问题，另外在内存上也会增加一定的开销。CombineMesh主要是针对于静态网格对象 如果是动态SkinMesh对象，往往由于美术为了材质表现效果，会通过Material id标记多维子材质，这样导入后会形成多个Submesh，每个不同材质的Submesh会增加一次DrawCall，我们在做平台移植或低端设备兼容时，可以合并多个材质与贴图，并通过通道图方式标记模型不同部位的材质变化 Texture： Unity默认提供了Sprite Atlas贴图，开发者也可以自己通过dcc合并同一模型上多张贴图到一张贴图上以达到纹理合并的方式 另外还可以通过TextureArray纹理数组方式向GPU同时传递多张设置相同的贴图资源 关于模型、贴图、材质这些资源的Batching，除了Unity官方提供的接口外，资源商店中也有很多资源可以使用 Shader变量与材质属性 在Build In管线下，Unity是通过Material Property Block完成合批的 而在SRP管线下则是通过Const buffer来实现的，并且通过定义不同的Const buffer，来控制提交到GPU上的频率，比如PerFrame、PerDraw、PerMaterial等Const buffer标签 Draw Call Batching 主要讲Static Batching与Dynamic Batching 与手动CombineMesh合并静态网格不同，Static Batching是引擎在构建时，自动将临近可合并的静态网格对象合并到一起，并将合并后的网格转换到世界空间下，并用它们的顶点信息构建一个共享的顶点缓冲与索引缓冲区，然后对可见网格进行简单的绘制调用。 值得注意的是：无论是CombineMesh还是Static Batching都不是在运行时合批的，如果你需要在运行时合批，可以通过Unity提供的StaticBatchingUtility.Combine的方法进行运行时合批，这对于一些运行时动态生成网格的对象特别有效，如需要动态关卡生成的Roguelike游戏。运行时合批时，你就不需要勾选BuildSetting中的Static Batching了 此外Static Batching功能依旧会有额外的内存开销，所有合批的网格对象都会在内存中保留一份额外的拷贝，是一个典型的空间换时间的优化方案 Dynamic Batching是对移动的游戏对象进行绘制批处理的手段，以减少绘制调用。Unity在运行时动态网格与动态生成几何体上的动态合批处理方式不同，Unity会将可动态合批的对象构建到一块大的顶点缓冲区中，并根据合批后的数据设置渲染器材质状态，然后将缓冲区绑定到GPU上，对于每个MeshRender是通过缓冲区偏移量来更新提交绘制内容的。做个类比，可以把静态网格对象理解成硬桃子，动态网格对象或动态生成几何体理解成软桃子，硬桃子量大、储存期长，你可以用火车起运，运输目的地可以较远，用途也更广一些；而软桃子为了避免腐烂，只可以做短距离小范围运输，甚至要就地加工，用途上会有更多限制。Dynamic Batching主要是为了一些低端、旧设备性能优化考虑的，在现代消费级硬件上，Dynamic Batching在CPU上的调用开销可能会更大，因此是否开启动态合批选项还需要在目标设备上测试使用，并不是无脑开启的 总之，无论是Static Batching还是Dynamic Batching，在使用上都有一些使用限制，稍不注意就会造成无法合批的现象 GPU Instancing GPU实例化也是一种Batching，用于渲染网格的多个副本。它是将基础网格对象传递给GPU后充分利用Instancing Buffer的方法，传递多个网格实例位置、朝向、颜色等其他属性构成的Instancing Buffer到GPU，避免了反复传递多个基础网格对象在世界空间下变换后的各种顶点数据和其他额外数据，所有的实例都会引用同一个基础网格对象，非常适合创建植被、石头等场景中大量重复的网格对象 GPU Instancing在Unity Build In管线与SRP管线下都支持，只不过在SRP管线中无法与SRP Batcher兼容，二者只能选择一个开启 需要开启GPU Instancing时，我们需要保障对应网格对象的材质中Enable GPU Instancing选项的开启 如果是自定义Shader，我们还需要定义Instancing Buffer的结构 值得注意的是，如果基础网格对象顶点数较少时，由于无法充分利用GPU资源，可能会导致性能不够理想，因此，对于顶点数较少的网格，我们需要反复测试，一般情况下不建议使用GPU Instancing Unity可以在脚本中通过直接（DrawMeshInstanced）、间接（DrawMeshInstancedIndirect）、间接程序化（DrawMeshInstancedProcedural）三个接口自定义绘制Instancing 其中第一个接口DrawMeshInstanced使用简单，但有实例化数量的限制；第二、三个更灵活一些，但实现相对复杂，可以在Unity文档中学习使用 Set Pass Call Batching 只有一类：SRP Batcher。顾名思义其仅能在SRP管线下开启 它可以显著减少Unity为使用相同着色器材质，准备和调度绘制的CPU时间开销 类比桃子运输装卸场景就是，使用什么交通工具、多少频率发一次货性价比最高 其核心是需要图形API支持的Const Buffer。这个Const Buffer中放什么、每个元素大小、Const Buffer总体大小以及什么时机以什么频率将Const Buffer中的内容提交给GPU，都是会影响最终性能的 好在Unity已经为我们定义好了一些Const Buffer类型，如 UnityPerCamera UnityPerFrame UnityPerPass UnityPerDraw UnityPerDrawRare UnityPerMaterial 上面几类SRP已经定义好的Const Buffer包含了引擎内置的一些Shader变量与属性，同时也指定了提交到GPU上的频率 而需要开发者定义的只有UnityPerMaterial这类的Const Buffer，这类Const Buffer只有在其定义属性发生变化时才会被提交到GPU上 我们需要将自定义的着色器变量与材质属性添加到这类的Const Buffer中，不能有在Const Buffer之外定义的其他属性或Uniform变量，确保SRP Batcher字段是compatible的，这一点非常重要 在SRP管线下强烈建议开启SRP Batcher功能，如果不使用此功能，个人觉得完全没必要升级到URP或HDRP管线 在URP管线中，自带的某些Const Buffer在定义上可以做一些精度上的优化，以提高Shader的指令效率 Batching优化顺序及优先级 资源Batching &gt; SRP Batching = Static Batching &gt; GPU Instancing &gt; Dynamic Batching "},{"title":"性能优化(21)——Unity中的Simplization","date":"2022-09-12T06:30:01.000Z","url":"/2022/09/12/performanceOptimization-18/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"Unity中的简化 Simplization就像桃子分类，将不同的桃子按不同品质大小分类装箱，以满足不同桃子产品的需求 类比到性能优化中，就是将各类资源、功能分类简化，以满足不同平台、不同设备、不同类型的产品需要 以URP为例，如何在Unity下做Simplization 哪些是需要简化的内容 广义上将： 运行效率较重的资源。如运行时内存占用较高，或处理耗时较长的资源 低效、不合适功能。某些低端设备或平台不能一味地去堆砌功能，更应该去考虑平台的兼容性和此功能的通用性，做到最好的性价比 这里的简化操作不能简单地理解为重新制作资源，应当理解成是基于现有的资源进行简化操作 通常情况下，我们最常用的简化手段就是分级配置，各种LOD结合一些场景数据结构做简化。当然还有一些替代体的方案 Unity下的简化手段(比较常用的手段) Quality Settings：通过这个设置，你可以自定义在不同平台、设备下，Unity现有的一些功能的设置分级。你可以预先设置在哪些平台下开启或不开启某些功能，包括分辨率、贴图分辨率、阴影质量等的一系列设置 通过烘焙光照简化实时光照：在静态灯光场景下，可以使用烘焙的方案替代实时光照方案 通过BoundingBox或替代体碰撞代替Mesh碰撞 用Local Volume代替Global Volume来做特效与后效的区分 用多条RayCast射线检测方式代替开销比较高的SphereCast、CapsuleCast等 用纹理字体代替系统文字 Mesh LOD：根据距离采用不同复杂度级别的Mesh进行渲染，以达到不影响视觉表现，同时带来更小的开销 Shader LOD：来做多平台或低端设备上的兼容性，尤其是一些Shader效果需要图形API版本要求时 HLOD：是Unity针对于大世界提出的一种简化方案。它可以在长视距下用单个静态网格组合替代多个静态网格对象，有助于减少场景渲染对象的个数，同时减少DrawCall调用次数来做场景渲染优化。这个方案会有一定的CPU与内存开销，要看具体项目类型测试后采用。Unity将例子与库都放在官方GitHub上了 通过Camera Override代替URP管线中的一些通用设置：避免了在管线中创建一些长时间无用的渲染资源，比如Copy Depth、Copy Color等这些创建的RP资源 各种OnDemand更新或分级设置接口：如OnDemandRendring … 用户也可以通过脚本或插件做一些自定义的简化操作 场景简化数据结构：如上一章Culling中提到过的场景数据结构，这类结构不仅可用作Culling，还可以做Simplization与Batching。其中如果是PC端做ReTracing的话，一定要用到场景数据结构来简化，要不纯像素的话，效率上根本达不到实时渲染。此外，SDF体素化、点云等都是做简化渲染的重要手段 第三方LOD方案：如Automatic LOD、Poly Few|Mesh Simplifier and Auto LOD Generator、Mesh Simplify、Amplify Impostors等，在资源商店搜索LOD或Simplify可以找到很多插件 Mesh Impostor Animation LOD：不光模型，动画方面也可以尝试做LOD。比如做动画频率的LOD，可以根据视距降低远处角色的动画频率，或使用骨骼LOD为远距角色采用另一套骨骼较少的骨骼框架 2D寻路代替Navigation Mesh 扩展类似OnDemand接口：实现按需创建或按需更新的逻辑，对于一些复杂的游戏资源或逻辑也是非常必要的 总之除了利用好Unity本身的Simplization操作功能外，我们在写功能时也要有多级可配置简化的思想，这样会让你最后优化产品时，不至于由于无法简化而不得不更换方案或重新开发 "},{"title":"性能优化(20)——渲染提前期优化——Culling、Simplization、Batching","date":"2022-09-09T04:56:53.000Z","url":"/2022/09/09/performanceOptimization-17/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":" Culling（剔除）、Simplization（简化）、Batching（合批） 这些优化都是为了缩短渲染提前期，是为了进GPU管线渲染前所做的优化。将这三个过程类比桃子食品加工生产销售前的过程：将Culling剔除理解为摘桃子阶段，去除不适合的树枝和叶子、腐烂的桃子等，因为它们不适合生产；Simplization理解为为桃子分类，将不同的桃子按不同品质大小分类装箱，为了生产不同的桃子产品，或满足不同的销售渠道；Batching合批可以理解为将桃子装载发货的过程，近距离的放普通的货车，有保险需求的上冷藏车，大量需求的上火车，时间需求的上飞机，有的地方一天一发货要怎么安排运力，有的地方一周一发货要怎么安排运力，总之要保证下游能源源不断地得到桃子供应，而不会中断生产加工或销售的流程。而这些过程一般都发生在生产之前，类比于进入GPU管线之前，通常情况下这些工作都由CPU端负责，但一些特殊的生产流程可以利用生产流水线的特殊功能对桃子进行分类、清洗、剔除残次品，这个过程可以理解为做了GPU加速，将本该属于CPU端的工作放到了GPU流水线中进行了。其实总体而言，Culling剔除、Simplization简化、Batching合批三者在实际应用中并不孤立，相反是要紧密结合使用的，它们对渲染前的优化是非常重要且必要的 Culling剔除 哪些是需要剔除的内容 广义上讲： 看不见的像素、网格和对象 重复的、用不到的资源 不需要、不执行的代码 其中，剔除看不见的像素、网格和对象的方法： 像素剔除：摄像机平截头剔除、Back-face Culling（背面剔除）、Early-Z、Pre-Z Pass。其中摄像机剔除、背面剔除与Early-Z都是渲染库或硬件直接支持的部分，而Pre-Z Pass是针对于前向渲染下Early-Z失效的情况下，通过Pre-Z Pass方式提前获取场景深度，后续绘制像素时，根据场景深度外壳进行像素着色计算的剔除。是Unity2021URP下直接提供的新功能 网格对象级别的剔除：Unity提供了Layer Mask、可视距离对象剔除与Occlusion Culling的方案，前两种都可以通过简单的设置完成，而Occlusion Culling是一种CPU+烘焙的方案，在某些OverDraw严重而又存在大面积建筑或遮挡体类型的游戏中，可以起到加速的效果，但Occlusion Culling本身是一把双刃剑，由于烘焙会有额外的内存开销，而所有关于遮挡剔除的计算又在CPU端，会由额外的CPU开销。如果剔除给GPU端的优化弥补不了CPU端的开销时，这种方案可能是一种负优化，需要测试使用 灯光剔除：这部分需要依赖特殊的图形库和硬件的架构完成，比如Tile-Based Deferred Rendering，也就是通常所说的TBDR管线和Forward+渲染管线，针对于多实时光源在游戏项目上的光源剔除优化，在灯光处理上会为每个Tile建立可用的灯光列表，这时不能影响该Tile内像素的灯光将会被剔除在列表之外，这样在计算该Tile中的像素着色时可以大大节省像素光照着色的开销。目前URP下的Tile-Based延迟渲染在Unity2021中已经支持。URP Forward+管线目前仍在实验阶段，但仍可在Unity2021URP下通过定义URP_ENABLE_CLUSTERED_UI的宏来开启，从宏定义中我们也可以看出URPForward+采用的加速结构是基于Clustered的。对比而言，即使Tile-Based延迟渲染在带宽与内存上做了优化，但仍会比Forward+要高，而Forward+的性能瓶颈依然在场景对象复杂度上。因此如何选择管线要根据自己的游戏类型和目标设备来进行选择 场景剔除：是针对于大场景、多场景拼接的地图，这时我们可以通过Unity Additive的场景根据逻辑来做异步的加载和卸载，以实现场景的动态剔除，这也算是另类的Culling的一种了 除Unity提供的一些Culling的优化方案外，用户也可以扩展自己的Culling优化方案。如默认Unity下没有场景数据结构管理，可以通过添加各种场景结构来对场景中的对象进行管理，如Octree、BSP Tree、Portal等，还有对整个场景进行体素化（Voxelization），或者计算场景的SDF，这些数据结构都是为了做Culling加速或其他功能的必要数据。另外还有一些利用GPU加速的算法，如通过Hi-Z Pass利用上一帧的深度图和摄像机矩阵；利用Temporal Reprojection Culling算法来对当前这个场景做剔除；另外还有Cluster、Tile-based Visible Buffer算法，这些都可以在Unity的管线中进行扩展集成。 一般而言，基于GPU的Culling方案在移动端都会面临兼容性的问题；而基于CPU的方案往往都会存在可能变成负优化的双刃剑。其实没有任何一种Culling方案能适用于所有游戏项目，如果想扩展自己的Culling方案，往往需要代码实现的功能能力要大于理解算法本身的能力，所以不是优化到极致或者超大规模商业项目，一般很少有团队会去尝试 "},{"title":"性能优化(19)——Postprocess后处理优化","date":"2022-09-08T13:42:18.000Z","url":"/2022/09/08/performanceOptimization-16/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; Unity URP下支持的后处理效果分类 色彩校正与增强：我们做游戏依旧是在原始美术贴图、材质光照上做调整，不能完全依靠后期色彩校正来处理。换句话说不是不能用，而是不能胡乱堆砌 画面增强类：这类后处理效果一般需要额外的Render Pass处理，涉及RP的切换与与采样开销都比较高，因此整体性能开销也比较大，所以尽量不要叠加使用。如果非要使用，建议不要采用Global Volume方式一直开启，而是采用Local Volume方式在不同逻辑下进行开启，比如色散分离只在受伤类情况下开启，景深只在过场动画开启等 镜头效果：这类效果一般是Shader计算量比较大，也有一些纹理采样的开销，总体开销介于前两类之间，使用这类镜头特效应与第二类特效一样，建议通过Local Volume设置或通过逻辑开启 Unity URP下支持的后处理效果列表 Bloom：这是一个全屏泛光的效果，还可以通过指定污垢贴图形成泛光与镜头污垢结合的效果，但更常用的是泛光效果，这也是在移动平台中最常用的后处理效果，但在一些低端移动设备上的开销还是较重的 Channel Mixer：是通道混合器，可以通过修改每个颜色通道的输出，调整整体效果。除一些特殊表现外，我们更习惯通过HUE去调整，所以平时使用到它的几率也很小 Chromatic Aberration：能在图像敏感分界边界产生RGB散射的彩色条纹，用来模拟相机的镜头无法将颜色聚合到一起的颜色失真效果，一般也可以用来表现机器人视觉或屏幕破碎导致的屏幕失真效果。除特殊需求外也很少用到。由于它会对原屏幕贴图进行重复的三次采样去乘以位移uv，所以有一定的纹理采样开销 Color Adjustment：用来调整最终画面整体的色调、曝光度、HUE、亮度和对比度，用来增强画面的颜色效果，还是算比较常用的。它的处理根据ColorGradingMode模式的不同分为HDR与LDR模式 Color Curves：主要是在特定的范围内调整色调、饱和度、亮度和对比度，可以实现特定的色调替换和某些亮度降低的效果。可以作为Color Adjustment的进一步调整，但我们一般通过Color Adjustment调整基本已经满足绝大多数需求，因此此效果使用也很少 Depth Of Field：景深。由于其在移动设备上开销还是很大，因此在游戏过程中很少直接开启，一般作为实时渲染过场动画时，可以通过节省逻辑开销来换取景深的开销，以此来提升过场动画的表现。它分为高斯与散景两种景深模式，一般散景模式下，既可以使用近场景深也可以使用远场景深，性能开销会比较大；高斯模式一般是用作表现远场景深，效果相对较差，但开销也相对较小。如果是移动设备，建议使用高斯模式的景深 Film Graim：用来模拟胶片的随机光学纹理造成的胶片颗粒感效果，一般在特殊表现下使用，性能也会随着颗粒感强度与噪点响应曲线的降低而增加。另外，它需要采样多张预制的Lookup纹理，因此它也存在一些纹理采样开销 Lens Disortion：镜头失真效果，通过扭曲最终渲染图片来模拟真实的镜头效果，开销较小但应用场景不多 Lift,Gamma,Gain：是通过三个在轨迹球上的点的位置，在给定的颜色范围内，将图像色调移向该颜色，也是属于图像颜色校正的一类，应用并不多 Motion Blur：是模拟真实摄像机在拍摄移动问题，或者摄像机本身快速移动导致图像画面模糊的效果。目前URP还没有完全结合MotionVector，因此只能实现摄像机本身的移动模糊。Motion Blur的优化可以依据其本身的质量分级、设置模糊强度、摄像机旋转产生的速度具有最大长度这几个参数来优化。但在移动端仍建议不要一直开启，在一些过场动画和局部逻辑中使用尚可。建议将质量设置为Low的同时，将Intensity与Clamp值在不影响效果的情况下设置得越小越好 Panini Projection：帕尼尼投影，可以帮助你在很大视野的场景中渲染透视图、阴影、中调、高光，这个效果是用来重新定义阴影、中间调和高光的色调范围，而Split Toning会根据亮度值对图形的不同区域进行着色，以获得具有特色的表现。这几个效果使用率都较低，也没有什么可优化空间，只做简单介绍 Tonemapping：是将HDR值重新映射到新的颜色范围内的过程，最常用的就是ACES Tonemapping，即使在移动设备上还是有机会用到 Vignette：渐晕效果，说白了就是四边暗角的效果。它有一定的计算开销。在游戏中由于UI的存在，使用的话会很奇怪。一般用于无UI过场动画或截图的时候 White Balance：白平衡主要是用来消除不真实的偏色，以白色作为参考色，在最终图像中创建偏冷或偏暖的感觉。在游戏中应用的机会不多 Lens Flare：镜头光晕特效，是为了一些特殊画面增强设计的，如太空、林间阳光、镜头光晕效果等。开销与其组件Occlusion设置和光晕数量有关，建议只在有需求时开启 值得注意的是，尽量将不需要的效果直接删除，而不是通过复选框禁用。因为有些效果即使你禁用了，它的一些渲染资源依旧会被预先绑定，会导致内存的浪费 Color Adjustments优化选项来自URPAssets中对Post-processing字段的设置 Crading Mode中的High Dynamic Range（HDR）模式更适合电影制作工作流中的高精度分级，如果我们是游戏，也可以采用Low Dynamic Range（LDR）模式 另外，LookUpTexture的纹理大小（LUT size）可以调整，HDR模式下默认是32，在平衡效率与质量时，我们还可以在LDR模式下使用16位模式 还有sRGB与线性空间转换（Fast sRGB/Linear conversions），使用速度较快但精度较低的近似函数选项。在优化时我们评估低端设备上画面损失与性能提升的性价比，可以参考勾选此选项。但要说明一点的是，如果支持浮点精度纹理的平台或设备，Color Grading的HDR模式效率会更高 "},{"title":"性能优化(15-18)","date":"2022-09-08T08:25:25.000Z","url":"/2022/09/08/performanceOptimization-15/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 移动平台优化顺序 先优化ios，再优化android 苹果在ios平台上有比较强大的性能分析工具 ios平台的设备较少，不像android那样硬件千差万别，各家的操作系统也五花八门 先共性性能优化，再兼容性方面的性能优化 一般共性的性能问题，ios优化好了，android平台也就差不多了，只需要对特殊的硬件和系统做兼容性优化处理即可 Unity下常见的等待函数（Profiler下） URP下SSAO的优化 通过开关SSAO，可以看到画面中一些模型的拐角处和连接处的明暗对比会更明显，画面的立体感和层次感会更丰富 Downsample选项：选择这个选项可以降低生成中间纹理的分辨率，以降低纹理采样数，这对SSAO整体效率提升是非常明显的 默认在URP下只提供降低1/2分辨率的设置，我们可以尝试修改为原始分辨率的1/4大小，这样整体纹理采样率就会降低到原来的1/16 此外URP中只对AO第一张中间纹理做了降采样处理 我们还可以对其他模糊过程中的中间纹理进行降采样，以降低纹理采样的开销，当然这样降采样会带来视觉表现上的损失 你可以通过扩展SSAO的参数，为每张生成的中间纹理指定降采样系数，并将其暴露到编辑器上，这样通过可视化调整，达到既保障效率又满足视觉表现的平衡 After Opaque选项是将计算和应用SSAO放到不透明物体渲染之后，以改善在tiled-based架构的GPU上的效率。考虑到是移动端的优化，虽然它会造成物理理论上的一些不精确，但还是建议开启 当Source选项是灰的时，是因为工程是延迟渲染的，所以默认就会生成Depth和Normal的信息，用这两个信息可以生成更精确的AO。将Rendering Path改成前向渲染时，我们可以使用Depth生成Normal并计算AO信息，这时我们可以调整生成AO的精度质量 Intensity：是AO强度的设置，这个参数是影响混合系数，通过混合系数调整最终AO的混合强度。这个值一般不会影响效率，但我们可以通过它和其他选项配合一起做优化 Radius：AO信息计算的采样半径，这个值越大，GPU开销也就越大，一般我们要在可接受的视觉效果范围内，通过调低采样半径，调大AO强度来优化AO显示效果 Direct Lighting Strength：直接光影响的强度，这部分一般是指受直接光照的像素，来混合这个影响AO的系数，以此来调整表现效果，这个参数并不影响渲染效率，可以采用默认值 Sample Count：采样次数，这个值直接影响采样的循环次数，值越大性能开销也越大，虽然表现效果越好，但性能上是得不偿失的，一般在移动设备上应尽量保障最小采样次数下来调整AO的效果 SSAO进一步优化 使用HBAO(horizon-based ambient occlusion)或基于HBAO魔改的采样更少但AO效果更好的GTAO（Ground Truth Ambient Occlusion）方案替代SSAO 针对SSAO的Shader指令做进一步优化 可以采用烘焙AO到光照贴图的方案替换SSAO方案 反走样方案的发展 反走样主要是为了解决采样不足导致的问题，一般方案选择需要兼顾画面质量与渲染效率权衡的前提下对图像进行增强 反走样方案经过了从第一代SSAA到第二代MSAA、FXAA、SMAA，目前逐步被第三代的TAA以及未来的第四代DLSS所取代 目前Unity的URP下，AA的方案主要还停留在第二代 URP中的AA方案 效率：FXAA &gt; SMAA &gt; TAA &gt; MSAA 质量：MSAA &gt; SMAA &gt; TAA &gt; FXAA "},{"title":"性能优化(14)特别篇——性能优化之道","date":"2022-09-08T04:27:36.000Z","url":"/2022/09/08/performanceOptimization-14/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; 性能优化问题的本质 慢与快的问题 前提： 稳定性：不能因优化造成稳定性变差 兼容性：不能因优化导致兼容性变差 性价比：优化要有度，考虑成本与复杂度 性能优化的流程 影响性能的四大类问题 CPU GPU 带宽 内存 可以把GPU、CPU分别理解为生产相关产品的两个工厂；内存和其他存储视为仓库；带宽视为运输路线 性能的瓶颈可能会发生在两个工厂的生产能力、仓库的存储能力、工厂与工厂以及工厂与仓库之间的道路是否畅通、运输工具和运输能力是否跟得上 工厂内（CPU、GPU）也像整个工厂系统，它们内部也分为车间，也就是芯片内的逻辑处理单元（ALU）与工厂内的仓库比如L1、L2、L3级的缓存，以及它们之间的通讯总线。它们像车间与车间之间、车间与厂内仓库之间的道路等工厂系统。所以一旦定位到CPU与GPU上的问题时，我们还要再去看这个工厂内的系统优化。整个过程像套娃，优化也需要迭代进行 隐藏的几类小问题 功耗比 填充率 发热量 功耗比：可以理解为工厂生产相同数量的产品所需要耗费的能源。对比设备上，就是达到相同计算能力的耗电量。这对一些用电池的设备也是个性能指标。同样，功耗比越高，发热量也就会越大 填充率：可以理解为工厂运输道路使用50t/车的运输载具，载具每小时出发，但是你的工厂每小时只能生产30t的产品；或者说运输载具只有20t，你一车装不完，两车又浪费的情况。换到实际渲染中，纹理或资源很大，带宽一次传不过去，两次又浪费的情况。这时需要修改资源大小来匹配设备的带宽，避免填充率不足或带宽阻塞问题 发热量：比如你的芯片主频很高，但功耗比很差，那么发热量也一定会升高。另外还有一些移动设备不仅芯片发热，显示屏幕的功耗高也会造成发热。这些问题都会带来整体硬件环境温度高，一些操作系统会防止硬件温度过高而自动采取硬件降频的方式，这同样会带来一些性能问题 性能问题可能的情况（选择性采纳） 瓶颈可能性按由高到低的顺序排列（个人经验总结）： CPU利用率 带宽利用率 CPU/GPU强制同步导致的阻塞问题 片元着色器复杂 顶点Buffer可读写造成的CPU到GPU之间的传输问题 可读写的纹理CPU到GPU之间的传输问题 顶点着色器复杂 由于三角形数过多导致的几何复杂度过高 瓶颈检查优先检查CPU所带来的情况。而GPU端的瓶颈往往大概率是片元着色器的问题，这点瓶颈也很好确认，我们只需要改变显示分辨率即可快速确认是不是由于片元着色器所带来的问题 经常用的优化思路 升维与降维 一般来说，升维是用来优化性能，但从算法方面来说可能不太容易理解；而降维是为了方便理解算法，但性能往往会比较差。比如多线程并行程序往往会比单线程串行的更高效，当然前提是并行的优化要大于创建多线程资源的开销。 高维度也可以降低低维度上无法解决的问题，比如变换矩阵的齐次坐标、四元数解决万向节锁的问题等 维度转换，空间与时间，量纲转换 做优化要有维度转换的概念，如空间维度与时间维度的转化，面向对象设计的ASO到面向数据设计的SOA的转化，量纲的转化，积分变换等。这些都可以理解为维度的转换。 其中，以空间换时间是大多数算法优化最直接的方式，如通过缓存池避免每次分配带来的开销，TAA和DLSS都是通过时间维度上的卷积来实现优化的 你将一张2K大小的图弄成四帧1K大小的图哪里有省？处理的像素不是一样多吗？——有时间维度参与计算的话，上一帧处理的像素在下一帧可能没有发生变化，这样就不用重新计算，不就节省了吗 "},{"title":"性能优化(13)编辑器创建资源优化(5)——动画","date":"2022-09-07T13:47:04.000Z","url":"/2022/09/07/performanceOptimization-13/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"编辑器内创建动画资源的优化 &emsp; Unity动画系统回顾 Animation中的Animation Clip Animator中的Animator Controller Graph Playable API中的Playable Assets 其中Animation Clip主要是动画曲线资源。Unity的Legacy动画系统主要依赖于此类资源 Legacy动画系统主要是对应Unity4之前的动画系统，Unity4后Unity的动画系统改为Mecanim。这套系统中以上三类资源都会用到，其核心是Playable API。在Playable API基础上支持Animation C# Jobs、Timeline等。其中Animation C# Jobs主要是为了Animation Rigging与Kinematica高级动画提供高效的并行基础 上述三类动画资源的使用细节Animation 通过Animation窗口，我们可以创建与编辑游戏对象的各种属性的动画曲线 这些属性包括对象的Transform、材质颜色、光照亮度、声音音量以及我们在脚本中自定义的各种值 在使用上，Animation也最为简单，但我们需要注意一些性能的细节： 播放单个AnimationClip速度，Legacy Animation系统更快，因为老系统是直接采样曲线并直接写入对象的各种属性；而新的Mecanim系统，则具有用于混合的临时缓冲区，并会对采样曲线和其他数据进行额外的复制。请注意，这里的高效是指播放单个Animation Clip，而并不是整体的动画性能老的系统一定比新的系统高，后续会详细说明 针对动画的缩放曲线，比位移、旋转矩阵开销更大。因此我们尽量不要做对对象的缩放动画 常数曲线不会每帧写入场景，更高效 Animator Animator中的Controller对应Animation Controller Graph资源；Avatar是我们在导入时生成设置的 Animator动画系统更新的主要流程 其中白色的步骤是动画系统中各个时段的回调，灰色的步骤则是动画系统更新的关键步骤 最开始的是Animation Controller Graph中的动画状态机更新 接下来的ProcessGraph是对需要评估的所有Animation Clip进行采样，以及计算根骨动画（RootMotion） 再接下来的ProcessAnimation是计算动画图混合结果 WriteTransform是将所有动画变换从工作线程写入场景对象的Transform 最后的WriteProperties是从主线程中将其他动画属性写入到场景对象中 了解完新动画系统的更新流程，还需要注意Animator的一些细节： 不要使用字符串来查询Animator 使用曲线标记来处理动画事件 使用Target Marching函数来协助处理动画 将Animator的CullingMode（裁剪模式）设置成Based On Renderers来优化动画，并禁用SkinMesh Renderer的Update When Offscreen属性来让角色不可见时动画不更新 对比Animator与Animation Animation适合简单动画和较少动画组件的情况，而Animator更适合处理高动画曲线条数和更复杂的动画组件情况 Animator的弊端可以用Playable API来解决 Playable API Playable API是以一套树形结构来组织数据源，并允许用户通过脚本来创建和播放自定义的行为，支持与动画系统、音频系统等其他系统交互，是一套通用的接口 换句话说，在Unity中，所有带时间轴的资源，都可以用Playable API来播放 Unity中还提供了一套可视化PlayableGraph的工具：PlayableGraph Visualizer 对比Playable API与Animator PlayableDirector与Timeline Asset的关系 可以通过自定义的Track来扩展Timeline的轨道 并可以在Timeline轨道上通过Signal或Mark添加自定义的回调事件，这样Timeline工具可作为角色技能编辑器、过场动画编辑器的工具了 总结：解决方案选择 一些简单、少量曲线动画可以使用Animation或动画区间库如Dotween\\iTween等完成，如UI动画、Transform动画等 角色骨骼蒙皮动画如果骨骼较少，Animation Clip资源不多，对动画混合表现要求不高的项目（如开关门、车辆、简单角色）可以采用Legacy Animation。要非常注意控制总体曲线数量 一些角色动画要求与逻辑有较高的交互、并且动画资源不多的项目可以直接用Animator Graph完成。这种情况要非常注意动画状态机中的状态机节点个数，避免使用过多的动画状态机节点与层 对于动作游戏，对动画混合要求较高、有一些高级动画效果要求、动画资源庞大的项目，建议采用Animator+Playable API扩展Timeline的方式完成（这时状态机中一般只有一个基础节点-走跑跳，而一些特殊的如技能、持不同武器的动画状态模组以及过场动画的表现都使用Playable API去扩展Timeline完成）。 "},{"title":"Unity Shader入门精要 第九章","date":"2022-09-04T09:09:04.000Z","url":"/2022/09/04/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"中级篇 9.1 Unity的渲染路径9.1.0 在Unity里，渲染路径（Rendering Path）决定了光照是如何应用到Unity Shader中的 因此如果和光源打交道，就需要为每个Pass指定它所使用的渲染路径 使用摄像机组件里的Rendering Path可以覆盖Project Setting里的设置 前向渲染路径的原理 Important：告诉Unity这个光源很重要，会被当成逐像素的光源使用 Not Important：告诉Unity这个光源不重要，会被当成逐顶点或SH的光源使用 9.1.1 内置的光照变量和函数 前向渲染可以使用的内置光照变量 前向渲染可以使用的内置光照函数 9.1.2 顶点照明渲染路径 Unity中的顶点照明渲染 可访问的内置变量和函数 9.1.3 延迟渲染路径 延迟渲染的原理 Unity中的延迟渲染 可访问的内置变量和函数 9.1.4 选择哪种渲染路径 9.4 Unity的阴影9.4.1 阴影是如何实现的"},{"title":"性能优化(12)编辑器创建资源优化(4)——物理","date":"2022-09-03T01:37:25.000Z","url":"/2022/09/03/performanceOptimization-12/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; Unity中的物理 Box2D Nvidia PhysX Unity Physics Havok Physics for Unity Unity中的默认2D物理解决方案是使用的开源Box2D库完成的，它是一套高效的2D刚体物理的C++代码库，也是在做2D物理游戏开发时经常选择的解决方案。 而Unity中的3D物理默认解决方案是使用的Nvidia的PhysX库。这套库一直有一个比较大的问题，它是一套非确定性物理模拟库，也就是说，即使你两次输入相同的物理条件，依然会在后续模拟表现上呈现出不同的物理表现效果，这也让它在一些状态同步的网络游戏中无法做逻辑处理，而帧同步的网络游戏中又因其更新频率与渲染频率的不同，以及服务器演算物理时负载过重的问题，只能在一些客户端上做物理表现渲染 为了物理模拟的确定性，Unity还推出了一套符合DOTS设计理念的新的物理库——Unity Physics。但它无法像英伟达的Physics那样提供完整的全套的物理模拟。只能在保证高性能的基础上实现一套更简单的功能子集。但它可以在单帧内完成多次物理模拟，以显示未来的预测，比较适合做网络游戏中的物理。虽然它无法做到基于显卡的硬件加速，但由于DOTS的存在它依然可以在一些多核CPU上做到比较高效的表现 此外unity还提供了一套基于Havok物理库的物理解决方案，同样是符合DOTS的设计理念，数据也可以与Unity Physics通用，它可以用来增强Unity Physics包的功能，不过除需要安装额外的Pacage外，还需要在使用前得到微软Havok的授权 Unity下如何对默认物理部分进行优化工程设置与编辑器设置方面 如果是2D物理，通过Physics 2D标签设置；如果是3D物理，通过Physics标签设置 这个界面最重要的是图形碰撞矩阵的设置。在默认没有配置的情况下，所有图层上的游戏对象都会默认创建与其他图层上所有对象的碰撞，这是相当低效的，所以我们需要为每种类型的对象定义不同的层，对于每个新图层，通过设置碰撞矩阵中与其他图层是否有碰撞关系来避免不必要的碰撞，以及在碰撞监听器上的检测。 除碰撞矩阵外，Physics标签下还有许多选项，大部分情况下我们不需要修改，除非有一些特殊需求 Auto Sync Transform选项：这个选项是在Transform组件发生变化时，强制进行物理系统同步，相当于在修改Transform后立即强制执行一次对物理对象的模拟更新，这样会增加物理运算负担，一般不开启。不开启的情况下不是说不更新，而是要等到FixedUpdate过程再去对对象进行物理更新。大多数情况下不开启也能满足视觉表现效果 Reuse Collision Callbacks选项：这个选项应尽量保持开启，这样在物理引擎对所有碰撞回调时会重用之前的Coliision碰撞结果的实例，而不会为每个碰撞回调重新创建一个碰撞结果的实例。由于大多数情况下碰撞结果实例只是数值上的变化，重用已经创建好的碰撞结果实例可以降低托管堆上的GC开销 物理解算器迭代次数的两个设置 Default Solver Iterations、Default Solver Velocity Iterations选项：分别与物理碰撞精度、与碰撞后物理模拟精度有关。迭代次数越高，模拟越精确。实际使用时可以根据自己项目上的物理模拟表现的精度来调整迭代次数，一般情况下选择默认设置就好，因为迭代次数越高，物理模拟计算开销越大 Broadphase Type选项：由于3D物理使用的时Physics SDK，在其中物理模拟扫描场景时有粗筛和细筛的阶段算法，相当于用场景划分来对物理场景进行查找加速。我们可以根据自己的场景物理物体的复杂度与场景特点去选择不同的算法，一般默认就好。如果你的场景真的过于复杂，再去根据实际情况选择另外两个选项 在工程设置的Time标签下，对于FixedUpdate更新频率的设置。我们都知道，Unity默认情况下物理的更新都是在FixedUpdate中完成的。 这里默认设置的0.02ms代表每秒更新50次，这个更新频率越高，物理计算开销越大 对于一些低端手机如果帧率较低的情况下，50帧每秒的更新相当于每个渲染帧物理更新快2次了。可以适当降低一点物理的更新频率。但这个物理更新频率的降低也会带来一些副作用，比如对于一些高速运动的物理物体，如子弹，穿越比较窄的物理物体（如较薄的墙）时，当物理模拟更新频率不够高时，可能不会发生物理碰撞的回调，这时我们可以有两种方式来改善： 利用射线作为类似高速子弹的碰撞检测 利用两个渲染帧子弹的位置拉出一个包裹盒，再用这个包裹盒去与墙做碰撞检测 我们如果在Physics标签下禁用了Auto Simulation选项后，我们可以在C#代码中通过调用Physics Simulate接口来手动在任何逻辑位置更新物理系统 Time标签下的Maximum Allowed Timestep选项：限制了物理计算FixedUpdate事件在帧率下降时允许更新的最大步长，如果大于这个时间会出现一些奇怪的物理行为。因此合理的阈值可以避免物理模拟的错误，一般这个值推荐在8-10个FPS之间，大概是0.1-0.16ms之间 Collider与Rigidbody组件Collider 物理模拟与物理碰撞不是一码事。物理碰撞只是物理对象之间发生的Collision与Overlap的回调，并不会对后续的物理反馈做模拟，因此我们需要检查我们的对象是否同时需要Collider与Rigidbody组件。如果只需要触发回调并不需要添加Rigidbody组件 Trigger与Collider Unity Collider对象有很多种，如果能用简单的Collider替代复杂的对象的MeshCollider的话，尽量用简单的Collider。即使用多个简单的Collider代替一个复杂的MeshCollider也是值得的 Rigidbody Kinematic与Rigidbody 当有物体需要按固定的方式去运动，并且能触发碰撞，同时能对其他刚体造成影响时，勾选isKinematic选项，它比rigidbody的物理开销小 在Unity Profiler的物理模块中，勾选了is Kinematic选项的对象不会增加Rigidbody的数量 Unity中的RayCast与Overlap部分的优化 柔体、流体部分的物理并不常用"},{"title":"性能优化(11)编辑器创建资源优化(3)——UGUI（下）","date":"2022-09-03T01:37:21.000Z","url":"/2022/09/03/performanceOptimization-11/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; UI字体 避免字体框重叠，造成合批打断 字体网格重建 UIText组件发生变化时 父级对象发生变化时 UI组件或其父对象enable/disable时 UI字体 资源导入时的设置 TrueTypeFontImporter 支持TTF和OTF字体文件格式导入 Font Size：字体大小，是基于文字处理程序设置的大小 Rendering Mode：使用哪种字体渲染的平滑模式。默认使用Smooth就好，这种是在动态字体上最快的一种模式 Character：导入字体文件选择哪个字符集 Dynamic：在运行时渲染字体字形 Unicode：代表选择Unicode字符集 ASCII default set：代表选择ASCII码字符集 ASCII Upper Case：代表选择ASCII码中的大写字符集 ASCII Lower Case：代表选择ASCII码中的小写字符集 Custom Set：代表自定义选择字符集，选择这个选项时，我们可以从导入的字体文件中选择我们想要的字符 除第一种Dynamic外，其他5种都是静态字符集 接下来的几个选项都是字符边界的选项，一般默认就好 Include Font Data： 勾选时一般适合动态字体属性一起使用。 当选中复选框后，导入的TTF或OTF文件会随APP文件构建一起输出；如果没有勾上该选项则不会随APP一起输出。 如果使用的是对应操作系统中已有的字体，不勾此选项则可以节省内存与输出包大小；如果目标文件中没有该字体，则会在下面Font Name选项列表中选择一种后备字体使用。 也可以使用References to other fonts in project选项中指定的其他项目内的字体作为后备字体 当然我们还可以使用Unity编辑器中的Custom Font或通过TextMeshPro中的Font Asset Creator工具创建自定义式样的静态字体资源 选择Dynamic字符集后使用动态字体或字体图集需要了解的一些细节： 字体图集会按2的幂次大小进行扩大，图集大小只增不减（512x512 -&gt; 512x1024）,运行时，这会对我们的效率产生一定影响，所以在预加载或启动时，我们可以通过Font。RequestCharacterInTexture接口将运行时需要的字体提前加入到图集中，这样可以有效地减少启动时间或运行时字体图集动态扩展的时间 建议将TextMeshPro作为Unity文字处理的最佳方案 TMP使用有向距离场（Signed Distance Field 简称SDF）作为文本的渲染管道，可以以任意点大小和分辨率清晰地渲染文本，并在一些视觉特效上使用材质预设来处理，如轮廓、阴影、倒角、光晕等效果，而且效率更高 超采样：加大FontSize，减小Scale 简单地说：TMP记录的是一个字体的矢量形状，渲染时通过矢量方式来进行渲染，因此无论如何放大缩小它的清晰度都是不会改变的。这也就是TMP最大的优点 将Scene视图中的显示模式改为Overdraw（显示当前图像在屏幕中的填充率）后如下图所示： 在同样的屏幕范围内渲染多次就会产生overdraw，可以发现TMP基本不会出现重叠部分。在一般渲染情况之下已经比Text有一定的优势了 假如在Text上面添加一个描边组件如下图所示： 因为描边，它渲染了四次，对于屏幕填充率的占用，它的性能非常差 而使用TMP，只需对材质上的描边厚度进行添加，就完成了描边 因为本身TMP使用SDF有向距离场的方式来进行渲染的时候，它在渲染之前就已经把这个描边给计算出来了 因此TMP组件在性能上远远超过Text组件 缺点： 选中对应的材质。我们每次使用TMP，都会对现有的资源里的贴图进行修改，而这个贴图所占的空间是比较大的 在贴图被填满后假如不勾选Multi Atlas Textures（使用多张贴图）的话，新的字会显示不出来（显示口字）。为了避免这个问题，一般会选到4096x4096,并且勾选Multi Atlas Textures，同时减小Sampling Point Size到60、Padding到6（取样大小） UI控件优化的注意事项首先，不需要交互的UI元素，一定要关闭Raycast Target选项一定要使用OnDemandRendering接口降频，而不是直接调整TargetFPS。两者的区别是，OnDemandRendering接口只会降渲染频率不会降输入频率，而TargetFPS接口会渲染和输入一起降 滚动视图Scroll View 首先，它是个容器，需要大量实例化子对象控件，子对象控件简单点还好，如果过于复杂会有效率问题。不光对象大量实例化开销，由于视图滚动还要触发UI的Rebuild开销。这时我们需要做两个工作来进行优化： 使用RectMask2d组件裁剪，通过模板缓冲剔除不必要的渲染。注意不要使用不规则的滚动视图，因为RectMask2d没有使用模板缓冲，而直接使用Rect相交检测去裁剪，如果是不规则形状则需要PixelMask写额外的Shader来做剔除，这样会有额外的渲染开销 可以通过可视化位置构建子元素对象池，以减小内存与实例化的开销。这里的内存池是根据子对象的渲染位置来做的内存池，而不是对所有子对象做的内存池 "},{"title":"Unity Shader入门精要 第八章","date":"2022-08-31T04:16:48.000Z","url":"/2022/08/31/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"8.透明效果 8.0 深度缓冲：在实时渲染中，深度缓冲是用于解决可见性问题的，它可以决定哪个物体的哪个部分会被渲染在前面，哪些物体会被遮挡。它的基本思想是，根据深度缓冲的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存储在深度缓冲中的值进行比较（开启深度测试的前提下），如果它的值距离摄像机更远，说明这个片元不应该被渲染到屏幕上，因为有物体遮挡住了它；否则这个片元应该覆盖掉颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中 8.1 8.2 Unity Shader的渲染顺序 8.3 透明度测试 8.4 透明度混合 8.5 开启深度写入的半透明效果 ColorMask 0：该Pass不写入任何颜色通道，即不会输出任何颜色 8.6 ShaderLab的混合命令8.6.0 8.6.1 混合等式和参数 8.6.2 混合操作 8.7 双面渲染的透明效果"},{"title":"性能优化(10)编辑器创建资源优化(3)——UGUI（上）","date":"2022-08-30T06:50:50.000Z","url":"/2022/08/30/performanceOptimization-10/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; Unity UI性能的四类问题 Canvas Re-batch时间过长 Canvas Over-dirty，Re-batch次数过多 生成网格顶点时间过长 Fill-rate overutilization （UIshader中GPU片元着色器的利用率过高） Canvas画布 Canvas负责管理UGUI元素，负责UI渲染网格的生成与更新，并向GPU发送DrawCall指令 这些工作全是在引擎native层，由C++负责完成的。 对于每个Canvas对象，在绘制之前，都要进行一个合批的过程。 如果Canvas底下的所有UI元素，每一帧都保持不变，那么只需在绘制前合批一次，并保存下结果，并在之后的每帧渲染中继续使用这个保存的结果；如果UI元素发生了变化，这时画布需要重新匹配几何体，而画布被标记成dirty，这时被标记成dirty的Canvas会触发Re-batch，也就是重新需要合批 Canvas Re-batch（合批）的过程 1.根据UI元素深度关系进行排序 2.检查UI元素的覆盖关系 3.检查UI元素材质并进行合批 UGUI渲染细节 Re-Build过程 Re-Build是Re-batch过程中完成的，主要逻辑在C#层，用来重新计算Layout布局与渲染网格重建，每当Canvas组件调用WillRenderCanvases事件时，都会调用CanvasUpdateRegistry中的PerformUpdate方法，这个方法主要完成三个工作 通过ICCanvasElement.Rebuild方法重新构建Dirty的Layout组件 通过ClippingRegistry.Cullf方法，对任何已注册的裁剪组件Clipping Components的对象进行裁剪剔除操作，如已注册了Mask的UI元素 任何Dirty的Graphics Components都会被要求重新生成图形元素 Layout组件和Graphics组件什么时候被标记成dirty： Layout Rebuild UI元素位置、大小、颜色发生变化时 优先计算靠近Root节点，并根据层级深度排序的transform操作时会被标记成dirty并触发Layout Rebuild过程 Graphic Rebuild 顶点数据被标记成Dirty时 材质或贴图数据被标记成Dirty时会触发Rebuild过程 UGUI性能优化 使用Canvas的基本准则： 默认情况下，UGUI是通过Canvas的Graphic Raycaster组件来处理输入、触摸以及鼠标悬停事件。每个Canvas都会绑定一个Graphic Raycaster组件，并每帧检测鼠标鼠标的位置。Unity5.4之后，对于没有鼠标的设备不会进行每帧检测。如果不需要交互的Canvas对象可以禁用Graphic Raycaster组件 "},{"title":"性能优化(9)编辑器创建资源优化(2)——预制体","date":"2022-08-30T06:15:52.000Z","url":"/2022/08/30/performanceOptimization-9/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; 预制体 Unity中的预制体是用来存储游戏对象、子对象及其所需组件的可重用资源，一般来说预制体资源可充当资源模板，在此模板基础上可以在场景中创建新的预制体实例 使用预制体的好处 由于预制体系统可以自动保持所有实例副本同步，因此可以比单纯地简单复制粘贴游戏对象做到更好的对象管理 此外通过预制体嵌套（Nested Prefabs）可以将一个预制体嵌套到另一个预制体中，从而创建多个易于编辑的复杂游戏对象层级视图 可以通过覆盖各个预制体实例的设置来创建预制体变体（Prefabs Variant），从而可以将一系列覆盖组合在一起形成有意义预制体的变化 嵌套预制体与单预制体相比的优点与缺点 预制体变体 使用Prefab变体的一些限制 "},{"title":"Unity Shader入门精要 第七章","date":"2022-08-26T05:10:43.000Z","url":"/2022/08/26/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&nbsp; 基础纹理的介绍 纹理的最初目的：使用一张图片来控制模型的外观 使用纹理映射技术，我们可以把一张图贴在模型的表面，逐像素地控制模型的颜色 通常在美术人员建模的过程中，会在建模软件中利用纹理展开技术把纹理映射坐标存储在每个顶点上面，纹理映射坐标定义了该顶点在纹理中对应的2D坐标。通常这些坐标用一个二维变量：UV来表示，其中U是横向坐标，V是纵向坐标，因此纹理映射坐标也被称为UV坐标 尽管纹理的大小可以是多种多样的（256x256 1024x1024），但顶点UV坐标的范围通常会被归一化到0-1之间 纹理采样时使用的纹理坐标不一定是0-1范围内的 在OpenGL原点位于左下角，DirectX原点位于左上角，Unity符合OpenGL的传统 7.1 单张纹理 其中_MainTex_ST不是随意起的，而是主纹理”_MainTex” + “ST” 其中”ST”是缩放和平移的缩写，可以得到模型的缩放和平移值，通过.xy存储缩放值，.zw存储偏移值 在a2v里订阅了TEXCOORD0的语义，来声明一个新的变量TEXCOORD，Unity会将该模型的第一组纹理坐标存储到该变量中 在v2f结构体中添加了用于存储纹理坐标的变量”uv”，以便在片元着色器中来使用该坐标进行纹理采样 核心代码在片元着色器，在顶点着色器中只做一些简单的转换 // 声明一个v2f变量// 将模型空间顶点位置转换成裁剪空间// 模型顶点的法向量转换成世界空间下的法向量// 顶点空间下的顶点坐标转化成世界空间下的顶点坐标// 纹理坐标的变量uv：获取纹理坐标v.texcoord.xy,先缩放再偏移// 内置的宏，功能一样 参数：顶点纹理坐标，纹理名 核心的渲染代码，逐像素渲染 // 先计算世界空间下的法线方向 和 光照方向// 用cg的函数tex2D进行纹理采样 参数：被采样的纹理、纹理坐标// 计算环境光部分 ambient// 计算漫反射 diffuse// 计算高光反射 speoular 7.2 凹凸映射 目的：使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型顶点位置，只是让模型看起来好像是凹凸不平的，在模型的轮廓处可以看出破绽 第一种方法：使用一张高度纹理来模拟表面的位移，得到一个修改后的法线值，这种方法也被称为高度映射 另一种方法：使用一张法线纹理，来直接存储表面法线，这种方法也被称为法线映射 第一张方法中，使用一张高度图进行凹凸映射，高度图中存储强度值，用于表示模型表面局部的海拔高度，颜色越浅表明该位置的表面越向外凸起，颜色越深表明该位置的表面越向里凹。· 这种方法的好处是很直观，问题在于计算得更加复杂，在实时计算时不能直接得到表面法线，而是需要由像素的灰度值计算得到，因此也会消耗更多性能。· 高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息，也就是我们通常会使用法线映射来修改光照：nor = 2pi - 1 （需要模型空间一致）· 根据变换空间的不同，分为两种：· Bump是Unity内置的法线纹理，当我们没有提供任何的法线纹理时，Bump就对应模型自带的法线信息，而BumpScale则是用来控制凹凸的程度，当它为0时代表该法线纹理不会对光照产生任何的影响· 多了tangent语义，它告诉Unity把顶点的切线方向填充到这里，和法线方向的normal不同，tangent是float4类型而非float3，因为我们需要使用tangent.w的分量来决定切线空间中的第三个坐标轴，负切线的方向· v2f需要在顶点着色器中计算切线空间下的光照和视角方向，因此添加了lightDir和viewDir存储变化后的光照和视角方向· // uv的xy分量来保存纹理坐标，zw保存高度纹理坐标,减少了插值寄存器的使用，这样我们只计算和存储一个纹理坐标就可以了// 法线、切线坐标变换// 计算负切线时使用w。因为与切线和法线都垂直的方向有两个，w决定了用哪个方向· TANGENT_SPACE_ROTATION;加在o.lightDir=……上// 借助变换矩阵计算得到模型空间下的光照和视角方向，再借助该矩阵变换到切线空间中的光照和视角方向· 在片元着色器中得到切线空间下的法线方向和视角方向· 再借助tex2D对BumpMap采样· 在法线纹理中存储的是 把法线经过映射后得到的像素值· // 做反映射// 控制凹凸得到实际的xy分量// 由于法线是单位矢量，所以z分离可以用xy得到，因为x^2+y^2+z^2=1// 贴图部分 得到纹素值 albedo、ambient// 之后得到漫反射、高光反射 第二种方法：在世界空间下计算，需要在片元着色器中把法线方向从切线空间变换到世界空间下· 要使v2f中包含从切线空间到世界空间的变换矩阵，在一个插值寄存器最多只能储存float4大小的变量，对于矩阵这样的变量可以按行拆成多个变量进行存储· Bumpiness控制凹凸程度· Filtering哪种方式计算凹凸程度 渐变纹理 遮罩纹理"},{"title":"在Unity中制作MMD舞蹈视频","date":"2022-08-20T09:43:43.000Z","url":"/2022/08/20/UnityMMDCreateTutorial/","tags":[["unity","/tags/unity/"],["MMD","/tags/MMD/"]],"categories":[["教程文档","/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"content":"&emsp; 准备工作 创建工程。这里我用的是2019.4.31f1c1版本，有较好的插件兼容性 导入自己的场景和人物模型 导入插件包： Dynamic Bone 1.2.0即动骨插件，建议使用高版本，方便后续替换成PhysBone VRCSDK3-AVATAR-2021.11.24.16.20_PublicVRC官网下，建议使用高版本，方便后续替换成PhysBone VRC工具箱v1.2.5_by如梦来自B站 ，必须最后导入否则报错 布置场景 处理MMD文件 导入vmd模型动作文件 导入vmd镜头动作文件，并在文件名后面加上.bytes，即 xxx.vmd.bytes 导入音乐文件 使用菜单中的VRC工具箱 —— MMD动作转换 转换获得动作（不含表情） 复制一份动作出来方便修改k帧（不复制出来的是只读），取消勾选Bake Into Pose 创建 Animator Controller并给角色加上，增加一个Layer用来放表情动画，并加上Mask保险 导入MMD4UnityTools插件，用处是获得表情动画 下载地址： 导入完插件后修改MMDExtensionsEditor第300行附近的代码其中var chara = GameObject.Find(“Body”); 是获取表情的形态键所在的游戏物体以下为我的目录结构，仅供参考 修改完后就能够右键vmd文件创建表情动作了 将表情动作加到Animator中，双击点开表情动作，再点击场景中的人物模型，再在左上角下拉框选择表情动作，会发现下面的Missing提示这时只需手动按形态键名字添加上再复制关键帧即可只有一帧的关键帧可以先删除批量添加操作为：Ctrl按住+左键加选，选完后右键Add添加完后删除最后一帧，Ctrl+C复制Missing的所有帧，选中新添加的所有第一帧，Ctrl+V粘贴即可 添加相机动画：只需一个脚本，视频教程：不想看可忽略，继续看下文以下为该脚本 说明：其中有部分内容是经过我修改过的，在此指出： 将该脚本添加到下图所示物体上，并按对应的命名来设置相机的目录结构，VMDCAM为空节点，Camera为正常的主相机并为脚本附上对应的物体：.bytes文件、节点、相机、人物模型16. 最后为相机加上Audio Source组件加上音乐就完成啦17. 最后的最后推荐一个AssetStore的资源，叫做Unity Recorder，它能在运行游戏时帮你录制Game窗口的画面，并能直接录制4K画质，使用方便教程： 注： PhysBone比Dynamic Bone的物理性能高10倍； 最终若想发布则不能使用PhysBone因为需配合VRCSDK一起使用，而VRCSDK无法导出； 可以移除VRCSDK后再导出，当然也只能使用Dynamic Bone了。 任何问题可与博主交流，站内有联系方式 "},{"title":"MyShader1_CircleOnGround","date":"2022-08-19T15:26:19.000Z","url":"/2022/08/19/MyShader1-CircleOnGround/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"],["MyShader","/tags/MyShader/"]],"categories":[["开发记录","/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; 目标效果： 参考教程：   首先是通过shader产生一个跟随玩家的图形 shader代码： 效果： 中心点跟随玩家代码： 接下来修改为透明材质 在Properties块中添加一个新的property，这使得我们可以全局控制透明度 改变渲染队列 在#pragma声明中添加一个新的参数：alpha参数。意思是：使用名为surf的Surface Function，使用内置的Lambert光照函数，开启透明通道 最后，在surf()函数中添加控制透明度的代码 效果： 调整圆半径和变宽后效果： 以后再研究！"},{"title":"性能优化(8)编辑器创建资源优化(1)——场景","date":"2022-08-19T06:12:01.000Z","url":"/2022/08/19/performanceOptimization-8/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; "},{"title":"性能优化(7)Unity工作流(2)——资源导入工作流","date":"2022-08-19T04:22:23.000Z","url":"/2022/08/19/performanceOptimization-7/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; 资源导入工作流的三种方案 手动编写工具 利用Presets功能 利用AssetGraph工具 一、手动编写工具· 所有资源都有对应的OnPreprocessXXX接口，会在资源被导入时调用，也是我们修改资源导入设置的最佳时机· 在这个接口下我们会拿到导入资源的Importer接口，修改它的导入设置属性即可完成对导入设置的修改· 伪代码：· 虽然通过这个对象接口修改资源导入很直接简单，但还需要思考几个问题：· 1.同类型资源也有不同的设置，我们通过一套代码怎么能实现多套配置呢，显然我们不可能将所有配置通过代码分支判断来完成，这就要通过不同文件夹对不同配置的相同类型资源进行区分；或者通过文件名区分。这样我们的导入设置工具就还需要对路径进行管理，并要做表达式或通配符的资源搜索管理。· 还需要对导入资源设置做持久化，可以利用继承ScriptableObject对象来持久化设置完成。也可以通过Preset来完成· 2.即使完成了对资源的导入设置，后续在编辑过程中，仍可能对其进行修改，或者由于其他开发者误操作导致资源设置发生变化。这时该怎么办呢？· 大部分开发者是将导入工作流与打包发布工作流结合起来，就是在打包发布前对导入设置重新进行检查设置。但这样有一个弊端，就是：某些错误或性能问题只有到真包上才会发现，而我们希望在编辑器模式下能够立即处理来避免误操作修改。这就要引出一个新对象：AssetsModifiedProcessor 二、利用Preset· Presets的保存与应用：· 1. 在我们创建好一个游戏对象后，在其Inspector组件界面中，所有组件的右上角都有3个按钮· 2. 点击中间的按钮，我们可以将当前组件的属性通过Save current to…按钮序列化成Asset，并在下一次打开该按钮后应用此组件设置到游戏对象上· 同样资源的导入设置也可以持久化成Presets· 3. 我们还可以将Presets资源添加到资源设置中的Preset Manager中，这样在下次创建该对象组件或导入新资源时，都可以将该组件Presets或资源导入设置应用到新的对象或新资源上· 因此我们可以在Preset Manager中根据资源类型和不同的需求添加多个Preset来完成资源导入设置· 在Preset Manager中还可以为每一个Preset添加高级过滤搜索选项· 解决导入后的人为修改导入设置，或误操作导致设置变化的问题：· 利用之前提到的AssetsModifiedProcessor资源变化后调用的回调接口重新设置导入设置，只需将文档中提供的代码放到Editor文件夹下，同时删除Preset Manager中的默认预设，并将Presets放到对应资产文件夹中即可 三、AssetGraph工具· 从Unity Github官方仓库中搜索AssetGraph，并通过PakageManager下载安装· 并通过Unity下的Windows菜单 —— AssetGraph —— Open Graph Editor打开AssetGraph编辑器，并创建一个默认的AssetGraph资源· 这时我们可以向其中添加各种资源处理节点· 最常用的流程示例：加载资源目录节点 —— 过滤节点 —— 分组节点 —— （导入设置复写节点） —— 打包配置节点 —— 打包执行节点与输出节点· 可以勾选菜单中Use As Postprocessor来检测新资源导入的回调流程，并可以通过Execute按钮执行整个资源处置流程· 当然也可以删除后续节点，只运行到资源导入设置复写节点，来完成导入工作流 "},{"title":"Unity Shader入门精要 第六章","date":"2022-08-18T02:20:06.000Z","url":"/2022/08/18/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"Unity中的基础光照 6.1.1 光源 6.1.2 吸收和散射 光线由光源发射出来后，就会与一些物体相交。通常，相交的结果有两个：· 散射（scattering）· 吸收（absorption） 6.1.3 着色6.1.4 BRDF光照模型 6.2 标准光照模型 把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算贡献度，分为 环境光、自发光、漫反射、高光反射 6.2.5 6.3 6.4 在Unity Shader中实现漫反射光照模型 6.5 实现高光反射光照模型 6.6使用Unity内置的函数"},{"title":"性能优化(6)Unity工作流(1)——工程目录与Assets目录设置","date":"2022-08-17T04:40:55.000Z","url":"/2022/08/17/performanceOptimization-6/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"Unity中的工作流优化 项目的工程结构 Asset文件夹 Library文件夹· 一般较大，主要是unity编辑器内部使用，不需要将此文件夹参与到代码托管中。每台机器在项目导入时生成的也有可能有差异，一般合作开发时，编辑器使用出现问题时，清理此文件夹并重新生成，可能会解决一些由于缓冲产生的问题。在以后你使用编辑器无法打开工程或打开工程出错时，不妨删除此文件夹重新生成看一看 Project Settings文件夹与UserSettings文件夹都建议托管到代码工程中 Temp文件夹与Logs文件夹都不需要进行代码托管 Unity Assets目录中的特殊文件夹及用途 Editor文件夹：主要用来存放编辑器下使用的一些脚本和资源，一般用来扩展Unity编辑器使用，不会发布到应用程序中，也不会在运行时运行 Editor Default Resources文件夹：用来存储编辑器下的一些默认资源，这些资源只能通过EditorGUIUtility.Load函数按需进行加载 Gizmos文件夹：用来存储编辑器中的特殊对象图标，用来标记特殊对象或位置，Gizmos允许将图形添加到Scene视图中，以帮助可视化不可见的设计细节。同样也不会发布到运行时 Plugins文件夹：用来存储扩展Unity功能的插件，包括C和C++编写的Native DLL Resources文件夹：· 用来存储一些原型设计时可以从脚本中按需加载的资源，通过Resource.Load接口加载此类资源，Assets文件夹中可以添加多个Resources文件夹。同样也可以是Editor文件夹的子文件夹，但其中的资源需要通过Editor脚本进行加载，并会从构建发布中剥离· 值得注意的是，Resources文件夹通常是Unity项目中性能问题的主要来源。使用不当很容易造成Unity项目构建出现膨胀，导致内存消耗过高、应用程序启动时间显著增加、应用程序包体过大等问题。强烈建议在正式项目中，不要使用Resources目录，应尽量使用AssetsBundle方式进行构建和加载资源 Standard Assets文件夹：用来存放导入的标准资源包，这个文件夹内的脚本编译优先级最高。一般情况下很少使用到此文件夹（根目录唯一） StreamingAssets文件夹：用来存放不随应用程序构建而希望独立于原始文件格式提供的资源，如单独的视频等流媒体文件。此文件夹内的文件可以按原样复制到目标计算机中，然后通过特定的文件夹单独访问该文件（根目录唯一） 补充: ScriptTemplates文件夹：脚本模板文件夹，与编辑器文件夹下Editor\\Data\\Resources\\ScriptTemplates文件夹同名，编辑器下的该文件夹内存放的是所有编辑器可调用的脚本模板 而编辑器下的该文件夹，会随unity编辑器的更新而重置，所以需要把自己的模板放在Asset下的ScriptTemplates文件夹内 Assets目录结构设计 合理的文件夹结构有助于资源分类、工作流优化与AssetsBundle资源的打包 根据项目大小不同、游戏类型的不同往往设计上也存在差异，并不能完全做到标准化。但在设计上还是有一些原则可以帮助搭建比较合理的目录结构 "},{"title":"性能优化(5)静态资源优化——动画导入设置","date":"2022-08-17T03:34:46.000Z","url":"/2022/08/17/performanceOptimization-5/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"&emsp; 模型导入设置中的Rig标签 在没有动画的模型导入时，在Animation Type使用None标签 在带动画的模型导入时： 骨骼框架优化的关键选项 Skin Weights 代表骨骼动画蒙皮顶点最多同时受几根骨骼影响 Optimize Bones Optimize Game Objects 模型导入设置中的Animation标签 这里的选项会随模型的动画文件类型有所不同，如Bake Animations选项，这个选项只对应于Maya、Max等DCC工具的原始文件格式，并且文件中使用了布料、流体等烘培动画时才有用。如果采用fbx格式，该选项会呈现禁用状态 Resmple Curves Anim.Compression 动画文件压缩的选项· 当使用动画压缩后三种选项时，在下边都会产生Rotation Error、Position Error、Scale Error选项，默认是0.5，代表变化小于这个误差的关键帧会被删除。值越小动画越精确 Animation Custom Properties 动画曲线数据信息 选中Animation Clip时，会有 这么 一段信息： 动画文件导入设置优化后 信息查看原则 看效果差异（与原始制作动画差异是否明显，以肉眼看不出明显差距为准） 看曲线数量（总曲线数量与各种曲线数量，总曲线数量越小越好，常量曲线比重越大越好） 看动画文件大小（在小几百k或更少合理，超过1M以上的动画文件考虑是否合理） "},{"title":"Unity Shader入门精要 第五章","date":"2022-08-16T06:46:21.000Z","url":"/2022/08/16/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":" 今天开始正式学习代码部分，将挑重要部分记录 初级篇大部分shader无法直接用在真实项目上，只是阐述原理的实现 创建一个最简单的shader 命名为5-2 修改代码为初始状态 写上Pass 模型的数据从哪里来 定义结构体 Unity提供的内置文件和变量 位置：…\\Editor\\Data\\CGIncludes CG/HLSL语义 Debug与渲染平台的差异 Shader整洁之道 "},{"title":"性能优化(4)静态资源优化——纹理导入设置","date":"2022-08-15T05:20:58.000Z","url":"/2022/08/15/performanceOptimization-4/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"纹理设置 Texture Shape· 2D 最常用的2D纹理，默认选项· Cube —般用于天空和与反射探针，默认支持DefaultNormal Single Channel几种类型纹理，可以通过Assets &gt; Create &gt; Legacy &gt; Cubemap生成，也可以通过C#代码Camera.RenderToCubemap在脚本中生成· 2D Array 2D纹理数组，可以极大提高大量相同大小和格式的纹理访问效率，但需要特定平台支持，可以通过引擎Svstemlnfo.supports2DArrav Textures接口运行时查看是否支持· 3D 通过纹理位图方式存储或传递一些3D结构化数据，一般用于体积仿真，如雾效、噪声、体积数据、距离场、动画数据等信息，可以外部导入，也可运行时程序化创建 Alpha Source· 默认选择Input Texture Alpha就好，如果确定不使用原图中的Alpha通道，可以选择None。另外From Gray Scale我们一般不会选用 Alpha Is Transparency· 指定Alpha通道是否开启半透明，如果位图像素不关心是否要半透明可以不开启此选项。这样Alpha信息只需要占1bit。节省内存 Ignore Png file gamma· 是否忽略png文件中的gamma属性，这个选项是否忽略取决于png文件中设置不同gamma属性导致的显示不正常，一般原图制作流程没有特殊设置，这个选项一般默认就好 Advanced选项 Non-Power of 2· 非2的幂次方选项，与原始文件的纹理大小有关，保持默认就好 Read/Write· 开启会导致纹理内存使用量增加一倍· 脚本逻辑中需要动态读写该纹理时，需要打开此选项 Streaming Mipmaps与Virtual Texture Only· 一般保持默认，以后再介绍 Generate Mip Maps· 什么时候不需要生成MipMaps：· 1. 2D场景· 2. 固定视角，摄像机无法缩放远近 Border Mip Maps 默认不开启，只有当纹理是Light Cookies类型时，开启此选项来避免colors bleedinq现象导致颜色滲透到较低级别的Mip Level纹理边缘上 Mip Map Filtering· Box 最简单，随尺寸减小，Mipmap纹理变得平滑模糊· Kaiser，避免平滑模糊的锐化过滤算法 Mip Maps Preserve Coverage 只有需要纹理在开启mipmap后也需要做Alpha Coverage时开启。默认不开启 Fadeout Mip Maps 纹理Mipmap随Mip层级淡化为灰色，一般不开启，只有在雾效较大时开启不影响视觉效果 Wrap Mode、Filter Mode、Aniso Level 选择合适纹理过滤的最佳经验：（放到导入设置）· 使用双线性过滤平衡性能和视觉质量· 有选择地使用三线性过滤，因为与双线性过滤相比，它需要更多的内存带宽· 使用双线性和 2x 各向异性过滤，而不是三线性和 1x 各向昇性过滤，因为这样做不仅视觉效果更好，而且性能也更高· 保持较低的各向异性级别。仅对关键游戏资源使用高于 2 的级别 Filter Mode· 从上往下性能消耗变大，质量变好· Point：使用最近的滤波，在放大缩小时，采样像素通常只有一个，因此图像看起来会有种像素的风格· Bilinear：使用了线性的滤波，对于每个目标像素，它会找到4个临近像素进行线性插值混合后得到最终的像素，从而导致最终图像看起来有点模糊了· Trilinear：几乎和Bilinear一样，只是Trilinear还会在多级渐远纹理之间进行一个混合，多级渐远纹理技术是将原纹理提前用滤波处理来得到很多更小的图像，形成一个图像金字塔，每一层都是对上一层的图像降采样的结果，需要在实时运行时快速得到像素，但也会额外多占用33%的内存。· 一般使用Bilinear模式 各平台的默认纹理压缩格式详细细节：官方文档"},{"title":"性能优化(3)静态资源优化——纹理基础概念","date":"2022-08-15T04:33:27.000Z","url":"/2022/08/15/performanceOptimization-3/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"纹理基础概念 纹理类型 Default：默认的纹理类型格式 Normal map：法线贴图，可将颜色通道转换为适合实时法线贴图格式 Editor GUI and Legacy GUI：在编辑器GUI控件上使用纹理请选择此类型 Sprite(2D and UI)：在2D游戏中使用的精灵（Sprite）或UGUI使用的纹理请选择此类型 Cursor：鼠标光标自定义纹理类型 Cookie：用于光照Cookie剪影类型的纹理 Lightmap：光照贴图类型的纹理，编码格式取决于不同的平台 Single Channel：如果原始图片文件只有一个通道，请选择此类型 纹理大小 纹理的大小直接影响内存与显存占用的大小，同时对GPU纹理采样、CPU加载和带宽造成影响 选择合适纹理大小应尽量遵循以下经验：· 不同平台、不同硬件配置选择不同的纹理大小，Unity下可以采用bundle变体设置多套资源、通过Mipmap限制不同平台加载不同level层级的贴图· 根据纹理用途的不同选择不同的纹理加载方式，如流式纹理加载Texture Streaming、稀疏纹理Sparse Texture、虚拟纹理VirtualTexture等方式· 不能让美术人员通过增加纹理大小的方式增加细节，可以选择细节贴图DetailMap或增加高反差保留的方式· 在不降低视觉效果的情况下尽量减小贴图大小，最好的方式是纹理映射的每一个纹素的大小正好符合屏幕上显示像素的大小，如果纹理小了会造成欠采样，纹理显示模糊；如果纹理大了会造成过采样，纹理显示噪点。这一点做到莞美很难保障，奇以充分利用SceneView -&gt; DrawMode -&gt; Mipmap来查看在游戏摄像机视角下哪些纹理过采样，哪些纹理欠采样来调整纹理大小· 现代显卡对纹理的支持为2的幂次方，如1024x1024、512x256,不要求长宽相等，只要求长宽大小为2的幂次即可。不符合大小的纹理，Unity在导入时会自动设置成最小符合2的幂次方的大小，但这样的设置一定会造成纹理大小的浪费 纹理颜色空间 只需了解一下，知道纹理导入选项中的sRGB选项什么时候开启什么时候关闭即可 默认大多数图像处理工具都会使用sRGB颜色空间处理和导出纹理。但如果你的纹理不是用作颜色信息的话，那就不要使用SRGB空间，如金属度贴图、粗糙度贴图或者法线贴图等。一旦这些纹理使用SRGB空间会造成视觉表现错误 纹理压缩 纹理压缩是指图像压缩算法，保持贴图视觉质量的同时，尽量减小纹理数据的大小。默认情况下我们的纹理原始格式采用PNG或TGA这类通用文件格式，但与专用图像格式相比他们访问和采样速度都比较慢，无法通用GPU硬件加速，同时纹理数据量大，占用内存较高。所以在渲染中我们会采用一些硬件支持的纹理压缩格式，如ASTC 、ETC、ETC2、DXT等 纹理图集 是一系列小纹理图像的集合 优点：· 一是采用共同纹理图集的多个静态网格资源可以进行静态合批处理，减少DrawCal调用次数· 二是纹理图集可以减少碎纹理过多，因为他们打包在一个图集里，通过压缩可以有效的利用压缩，隆低纹理的内存成本和冗余数据 缺点· 美术需要合理规划模型，并且要求模型有相同的材质着色器，或需要制作通道图去区分不同材质。制作和修改成本较高 纹理过滤 纹理的Mipmap 逐级减少分辨率来保存纹理副本，可以理解为纹理的LOD层级。渲染纹理时，将根据像素在屏幕中占据的纹理空间大小选择合适的Mipmap级别进行采样 优点：· GPU不需要在远距离上对对象进行全分辨率纹理采样，因此可以提高纹理采样性能· 同时也解决了远距离下的过采样导致的噪点问题，提高了纹理渲染质量 缺点：· 由于Mipmap纹理要生成低分辨率副本，会造成额外的内存开销 "},{"title":"Unity Shader入门精要 第四章","date":"2022-08-12T02:27:10.000Z","url":"/2022/08/12/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"4. 学习Shader所需的数学基础 4.1 背景：描述一个物体的位置4.2 笛卡尔坐标系 4.2.1 二维笛卡尔坐标系· 原点· x轴和y轴· OpenGGL原点在屏幕右下角，往上y+，往右x+· DX原点在左上角，往下y+，往右x+ 4.2.2 三维笛卡尔坐标系· 多一个z轴· 左手坐标系· 右手坐标系 4.2.3 左手坐标系和右手坐标系· 将其中一个轴反向，就可以相互转化 4.2.4 Unity使用的坐标系· 对于观察空间，使用的是右手坐标系· 以摄像机为原点，摄像机前进方向为z轴负方向· z轴的减少意味着场景深度的增加 4.3 点和矢量 4.3.1 点和矢量的区别· 点是n维空间中的一个位置，没有大小，宽度的概念· 矢量是为了和标量区分开，矢量指n维空间中包含了模和方向的有向线段· 通常，矢量用来表示相对于某个点的偏移 4.3.2 矢量运算· 矢量和标量的乘除法 （1，2）x 2 =（2，4）· 矢量的加法和减法 （1，2）+（0，2）=（1，4）· 矢量的模 （1，2）模为（1^2+2^2）开根号· 单位矢量&emsp;转成单位矢量的过程是归一化&emsp;零矢量· 矢量的点积 —— 投影 (x1,y1)·(x2,y2)=x1x2+y1y2 =|a||b|cosθ· 矢量的叉积 —— 右手法则判断发现：模长为ab构成的四边形对角&emsp;二维：a x b = x1y2-x2y1&emsp;三维：a x b x c = y1z2-z1y2-x1z2+z1x2+x1y2-y1x2 （同高数）AxB=-(BxA) |AxB|=|a||b|sinθ 4.4 矩阵 4.4.1 矩阵定义：由一组数的全体，在括号内排列成m行n列的一个数表，并称它为mxn阵 4.4.2 和矢量联系起来：矢量可以看做列矩阵或者行矩阵 4.4.3 矩阵运算· 矩阵和标量的乘法· 矩阵和矩阵的乘法 4.4.4 特殊的矩阵· 方块矩阵· 单位矩阵· 转置矩阵· 逆矩阵· 正交矩阵 4.4.5 行矩阵还是列矩阵· Unity多把矢量转化为列矩阵来使用 4.5 矩阵的几何意义：变换 4.5.1 什么是变换· 线性变换：保留矢量加和标量乘的变换· 仿射变换：合并线性变换和平移变换的变换类型 4.5.2 齐次坐标· 将三维矢量转换成四位变量· 就可以表示三维的平移操作了 4.5.3 分解基础变换矩阵· 分成四个部分· 左上角表示旋转和缩放· 右上角表示平移· 左下角为0矩阵· 右下角是标量1 4.5.4 平移矩阵· 单位矩阵，右边一列为移动矩阵 4.5.5 缩放矩阵· 先是单位矩阵，前三个为缩放系数值 4.5.6 旋转矩阵· 绕轴旋转 4.5.7 复合变换 4.6 坐标空间 4.6.1 为什么要使用那么多不同的坐标空间· 在顶点着色器流水线阶段，做的就是把模型顶点坐标从模型空间转换到齐次裁剪坐标空间· 一些概念只在特定的坐标空间才有意义 4.6.2 坐标空间的变换· 对坐标机进行平移变换· 平移变换的变换矩阵的前3行和前3列，可以用来对法线方向、光照方向进行空间变换 4.6.3 顶点的坐标空间变换过程· 一个顶点需要经过多个坐标空间才能最终被画在屏幕上，一个顶点最开始是在模型空间中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标 4.6.4 模型空间· 模型空间（model space），是和某个模型或者说是对象有关的。有时模型空间也被称为对象空间（object space）或局部空间（local space）。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转· 在模型空间中，我们经常使用一些方向概念，例如”前（forward）””后（back）””左（left）””右（right）””上（up）””下（down）” 4.6.5 世界空间· 世界空间（world space）是一个特殊的坐标系，世界空间可以被用于描述绝对位置。在本书中，绝对位置指的就是在世界坐标系中的位置· 在Unity中，世界空间同样使用了左手坐标系· 但它的x轴、y轴、z轴是固定不变的。在Unity中，我们可以通过调整Transform组件中的Position属性来改变模型的位置，这里的位置指的是相对于这个Transform的父节点（parent）的模型坐标空间中的原点定义的，如果一个Transform没有任何父节点，那么这个位置就是在世界坐标系中的位置· 我们可以想象成还有一个虚拟的模型，这个根模型的模型空间就是世界空间，所有的游戏对象都附属于这个根模型。同样，Transform中的Rotation和Scale也是同样的道理· 顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform） 4.6.6 观察空间· 观察空间（view space）也被称为摄像机空间（camera space）· 观察空间和屏幕空间是不同的。观察空间是一个三维空间，而屏幕空间是一个二维空间。从观察空间到屏幕空间的转换需要经过一个操作，那就是投影（projection）· 顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换通常叫做观察变换（view transform）· 1. 一种方法是计算观察空间的三个坐标轴在世界空间下的表示，然后构建出从观察空间变换到世界空间的变换矩阵，再对该矩阵求逆来得到从世界空间变换到观察空间的变换矩阵· 2. 另一种方法，即想象平移整个观察空间，让摄像机原点位于世界坐标的原点，坐标轴与世界空间中的坐标轴重合即可。这两种方法得到的变换矩阵都是一样的，不同的只是我们思考的方式 4.6.7 裁剪空间· 顶点接下来要从观察空间转换到裁剪空间（clip space，也被称为齐次裁剪空间）中，这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也被称为投影矩阵（projection matrix）· 视锥体有两种类型，这涉及两种投影类型：· 1. 一种是正交投影（orthographic）：· 1.1 在透视投影中，地板上的平行线并不会保持平行，离摄像机越近网格越大，反之相反· 1.2 可以注意到，透视投影模拟了人眼看世界的方式· 1.3 因此，在追求真实感的3D游戏中我们往往会同透视投影· 2.一种是透视投影（perspective projection）· 2.1 而在正交投影中，所有的网格大小都一样，而且平行线会一直保持平行· 2.2 而正交投影则完全保留了物体的距离和角度· 2.3 而在一些2D游戏或渲染小地图等其他HUD元素时，我们会使用正交投影 透视投影· 在视锥体的6块裁剪平面中，有2块比较特殊，分别为近裁剪平面（near clip plane）和远裁剪平面（far clip plane）—— 通过一个投影矩阵把顶点转换到一个裁剪空间中 —— 首先是为投影做准备、齐次是对x、y、z分量进行缩放· 我们可以通过Camera组件的Field of View（简称FOV）属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近· 在Unity中，一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定· 根据已知的Near、Far、FOV、和Aspect的值来确定透视投影的投影矩阵 正交矩阵· 首先看一下正交投影中的6个裁剪平面是如何定义的· 正交投影的视锥体是一个长方体· 可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一半，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的近· 我们可以通过摄像机的横纵比得到横向信息Aspect 4.6.8 屏幕空间·屏幕空间是一个二维空间，因此我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标·首先，我们需要进行标准齐次除法（homogeneous division），也被称为透视除法（perspective division） —— 经过齐次除法后，透视投影和正交投影的视锥体都变换到一个相同的立方体内。在Unity中，从裁剪空间到屏幕空间的转换是由底层帮我们完成的。我们的顶点着色器只需要把顶点转换到裁剪空间即可· 根据变换后的x和y坐标来映射输出窗口的对应像素坐标 4.6.9 总结· 只有在观察空间中Unity使用了右手坐标系 4.7 法线变换 法线（normal），也被称为法矢量（normal vector） 切线（tangent），也被称为切矢量（tangent vector） 4.8 4.9 "},{"title":"性能优化(2)静态资源优化——模型","date":"2022-08-11T06:42:38.000Z","url":"/2022/08/11/performanceOptimization-2/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"模型的导入 尽可能使用fbx格式导入 优化原始导入模型文件。删除不需要的数据· 统一单位· 导出的网格必须是多边形拓扑，不能是贝塞尔曲线、样条曲线、细分曲面等，Unity不支持· 在导出之前确保所有Deformers都烘焙到网格模型上· 不建议模型使用的纹理随模型导出· 如果需要导入Blend shape normals时，必须指定光滑组Smooth groups· 建议导出时不携带如摄像机、灯光、材质等场景信息 原始模型对性能的影响点· 最小化面数，不需要微三角形面，三角面尽量分布均匀· 合理的拓扑结构与平滑组，尽可能是闭包· 尽量少的材质个数· 尽可能少的蒙皮网格· 尽可能少的骨骼数量· FK与IK节点分离，导出时删除IK骨骼节点 &emsp;以上主要是DDC模型导出需要注意的，美术人员需要注意的设置&emsp;下面为导入unity后的设置 在导入模型的Model选项卡下，Scene中，这些选项在没有特殊要求时可以不开启：Import BlendShaps、Import Visibility、Import Cameras、Import Lights Mesh Compression选项：· 默认为不开启· 在保证网格准确的情况下可以采用更激进的压缩方式· 可以时网格占用的磁盘空间更小，但运行时占用的内存不会变小· 开启后需要真正看一看模型有无问题，一般闭包的模型比开放式模型出现问题的概率更小 Read/Write选项· 禁用与开启读写选项· 启用后会在内存中额外复制一份此网格，一个副本保存在内存中，另外一个会保存在GPU显存中· 只有在运行时需要修改网格数据时才开启此选项· SkinMesh需要开启此选项来做动画· 剩下绝大多数情况需要确保此选项关闭以节省内存 Optimize Mesh和Generate Colliders选项· 一般保持默认设置，除非需要禁止优化，或者确切得需要做网格体碰撞· 启用 Generate Colliders 后，Unity会在您将网格添加到场景中时自动添加一个网格碰撞体，以便物理系统将其视为实体· 如果游戏对象正在移动（例如汽车），则无法使用网格碰撞体。必须改用原始碰撞体。此情况下应禁用 Generate Colliders 设置 几何体信息设置（Geometry）： Index Format选项· 如果确认网格顶点数不超过65535可以使用16位索引 如果确认不使用法线或切线，可以尝试关闭 如果不需要光照烘焙，可以关闭光照贴图的第二套UV生成 另外，在Project Settings —— Player下，Optimization下： Vertex Compression选项：设置每个通道的顶点压缩，可为模型除位置、光照、贴图、UV之外所有内容启动压缩 Optimize Mesh Data选项：开启后可根据网格使用的材质删除不需要的数据，如材质中没有使用到的切线、法线、颜色、UV等 无动画的模型需要在导入设置中的Animation标签下的Import Animation选项设置为关闭，并将Materials标签下的Meterial Creation Mode设置为None "},{"title":"性能优化(1)静态资源优化——音频","date":"2022-08-11T04:57:40.000Z","url":"/2022/08/11/performanceOptimization-1/","tags":[["unity","/tags/unity/"],["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"参考了B站up Metaverse大衍神君 的视频所做的记录 资源的优化 Assets工作流程：导入——创建——构建——分发——加载 关于资源的优化，也从这五步着手 外部导入资源：模型网格Mesh、纹理、音乐音效、字体动画、视频等。 内部创建资源：Prefab、Animation Controller、Timeline、RenderTexture、ParticleSystem、VFX等 无论哪种资源都需要涉及到Unity导入问题 在不同平台下，合理的资源导入设置与资源规格，可以给应用程序带来较高的效率 音频资源 Force To Mono选项：强制将双声道的音频改为单声道。当左右两声道音频完全相同时，开启此选项可以在内容不丢失的情况下，减小内存和大小，尤其是在移动平台 一般来说，尽可能得使用未压缩的wav文件作为音频源文件 在移动平台大多数采用Vorbis压缩方法 如果音乐不打算循环也可使用MP3格式 一些操作系统对特定的格式有额外优化，如IOS上可以使用MP3格式 对简短常用的音效可以使用ADPCM格式，这种格式可能压缩比不是最好的，但在播放过程中解码速度很快 还需要关注音频文件的采样率· 一般移动平台建议设置为22050Hz· 通常我们在移动平台都会选择对音质影响最小的最低设置 可以通过Sample Rate Setting选项修改默认的采样频率 越低的采样频率生成的导入文件越小 Load Type加载类型 影响的是Unity工作流中的第五步：加载· 默认是Decompress On Load，这个选项一般对应音频压缩后，大小小于200KB的音效文件· 如果大于200KB，则推荐使用Compressed In Memory· 如果是背景音乐文件或者较长较大的文件，推荐使用Streaming，通过流式加载避免载入时卡顿 当游戏需要静音时，不要简单得将音量设置为0，应该销毁音频（Audio Source）文件，将其从内存中完全卸载 音乐音效一般不会成为优化的瓶颈，但可以减小内存的使用和安装文件的大小，使用第三方的和带有复杂逻辑的除外 "},{"title":"Unity Shader入门精要 第三章","date":"2022-08-09T13:37:57.000Z","url":"/2022/08/09/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"3. Unity Shader基础 3.1.1 材质和Unity Shader 在Unity中，需要配合使用材质Material和Unity Shader才能达到需要的效果 流程： 1.创建一个材质2.创建一个Unity Shader，并把它赋给上一步创建的材质3.把材质赋给要渲染的对象4.在材质面板中调整Unity Shader的属性，以得到满意的效果 3.1.2 Unity中的材质 Unity中的材质需要结合一个GameObject的Mesh或者Particle System组件来工作，它决定了我们的游戏对象看起来是什么样子的 3.1.3 Unity中的Shader 为了和前面通用的Shader语义进行区分，这里把Unity中的Shader文件统称为Unity Shader Unity Shader和我们之前提及的渲染管线的Shader有很大不同 Unity中4种Shader模板： 1.Standard Surface Shader：产生一个包含标准光照模型的表面着色器模板2.Unlit Shader：产生一个不包含光照的基本的顶点/片元着色器3.Image Effect Shader：实现各种屏幕后处理效果4.Compute Shader：产生一个特殊的Shader文件，旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算（此书不讨论） Unity会显示Shader的相关信息：· 是否是一个表面着色器· 是否是一个固定函数着色器——Fixed Function Shader· 还有一些标签设置：是否会投射阴影、使用的渲染队列、LOD值 Show generated code· 打开一个新的文件，在该文件里面将显示Unity在背后为该表面着色器生成的顶点/片元着色器· 方便对生成的代码进行研究，需要复制到新的Unity Shader中才可保存 Compile and show code· 可以让开发者检查该Unity Shader针对不同图像编程接口编译成的Shader代码 3.2 Unity Shader的基础：ShaderLab 在Unity Shader的帮助下，开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有工作 3.3 Unity Shader的结构3.3.1 给我们的Shader起个名字 每一个Unity Shader文件的第一行都需要通过Shader语义来指定该Unity Shader的名字 这个名字由一个字符串来定义，例如”MyShader” 当为材质选择使用的Unity Shader时，这些名称就会出现在材质面板的下拉列表里 通过在字符串中添加斜杠（”/“），可以控制Unity Shader在材质面板中出现的位置 3.3.2 材质和Unity Shader的桥梁：Properties Properties语义块中包含了一系列属性（property），这些属性将会出现在材质面板中 开发者们声明这些属性是为了在材质面板中能够方便地调整各种材质属性 Int —— number —— _Int (“Int”,Int) = 2 Float —— number —— _Float (“Float”,Float) = 1.5 Range(min,max) —— number —— _Range (“Range”,Range(0.0,5.0)) = 3.0 Color —— (number,number,number,number) —— _Color (“Color”,Color) = (1,1,1,1) Vector —— (number,number,number,number) —— _Vector (“Vecter”,Vector) = (2,3,6,1) 2D —— “defaulttexture” {} —— _2D (“2D”,2D) = “” {} Cube —— “defaulttexture” {} —— _Cube (“Cube”,Cube) = “white” {} 3D —— “defaulttexture” {} —— _3D (“3D”,3D) = “black” {} 3.3.3 重量级成员：SubShader 每一个Unity Shader文件可以包含多个SubShader语义块，但最少要有一个 当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader 如果都不支持的话，Unity就会使用Fallback语义指定的Unity Shader Unity提供这种语义的原因在于，不同的显卡具有不同的能力 · SubShader中定义了一系列Pass以及可选的状态（[PenderSetup]）和标签（[Tag]）设置· 每个Pass定义了一次完整的渲染流程，但如果Pass的数目过多，往往会造成渲染性能的下降 常见的渲染状态设置选项：· Cull —— Cull Back | Front | Off —— 设置剔除模式：剔除背面/正面/关闭剔除· ZTest —— ZTest Less Greater | LEqual | GEqual | Equal | NotEqual | Always —— 设置深度测试时使用的函数· ZWrite —— ZWrite On | Off —— 开启/关闭深度写入· Blend —— Blend SrcFactor DstFactor —— 开启并设置混合模式 SubShader的标签（Tags）是一个键值对（Key/Value Pair），它的键和值都是字符串类型 SubShader的标签类型：· Queue —— 控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染（详见第8章），我们也可以自定义使用的渲染队列来控制物体的渲染顺序 · RenderType —— 对着色器进行分类，例如这是一个不透明的着色器，或是一个透明的着色器等。这可以被用于着色器替换（Shader Replacement）功能 · DisableBatching —— 一些SubShader在使用Unity的批处理功能时会出现问题，例如使用了模型空间下的坐标进行顶点动画（详见11.3节）。这时可以通过该标签来直接指明是否对该SubShader使用批处理 · ForceNoShadowCasting —— 控制使用该SubShader的物体是否会投射阴影（详见8.4节） · IgnoreProjector —— 如果该标签值为”True”，那么使用该SubShader的物体将不会受Projector的影响，通常用于半透明物体 · CanUseSpriteAtlas —— 当该SubShader是用于精灵（sprites）时，将该标签设为”False” · PreviewType —— 指明材质面板将如何预览该材质。默认情况下，材质将显示为一个球形，我们可以通过把该标签的值设为”Plane””SkyBox”来改变预览类型 Pass的标签类型· LightMode —— 定义该Pass在Unity的渲染流水线中的角色 · RequireOptions —— 用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前，Unity支持的选项有：SoftVegetation。在后面的版本中，可能会增加更多的选项 特殊的Pass· UsePass：如我们之前提到的一样，可以使用该命令来复用其他Unity Shader中的Pass· GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，以用于后续的Pass处理（详见10.2.2节） 3.3.4 留一条后路：Fallback 紧跟在各个SubShader语义块后面的，可以是一个Fallback指令。它用于告诉Unity，”如果上面所有的SubShader在这块显卡上都不能运行，那么就使用这个最低级的Shader吧！” · 我们可以通过一个字符串来告诉Unity这个”最低级的Unity Shader”是谁· 也可以任性地关闭Fallback功能 Fallback还会影响阴影的投射 3.3.5 ShaderLab还有其他的语义吗 就可以使用CustomEditor语义来扩展编辑界面 还可以使用Category语义来对Unity Shader中的命令进行分组 这些命令很少用到，本书不进行深讲 3.4 Unity Shader的形式 3.4.1 Unity的宠儿：表面着色器 表面着色器（Surface Shader）是Unity自己创造的一种着色器代码类型 背后仍旧把它转换成对应的顶点/片元着色器 Unity为我们处理了很多光照细节，使得我们不需要再操心这些 表面着色器被定义在SubShader语义块（而非Pass语义块）中的CGPROGRAM和ENDCG之间。原因是，表面着色器不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会在背后为我们做好这些事情 CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的，也就是说，我们需要把Cg/HLSL语言嵌套在ShaderLab语言中 3.4.2 最聪明的孩子：顶点/片元着色器 在Unity中我们可以使用Cg/HLSL语言来编写顶点/片元着色器（Vertex/Fragment Shader） 它们更加复杂，但灵活性也很高 和表面着色器类似，顶点/片元着色器的代码也需要定义在CGPROGRAM和ENDCG之间，但不同的是，顶点/片元着色器是写在Pass语义块内，而非SubShader内的 原因是，我们需要自己定义每个Pass需要使用的Shader代码 3.4.3 被抛弃的角落：固定函数着色器 而对于一些较旧的设备，它们不支持可编程管线着色器，因此，这时候我们就需要使用固定函数着色器（Fixed Function Shader）来完成渲染 可以看出，固定函数着色器的代码被定义在Pass语义中，这些代码相当于pass中的一些渲染设置 对于固定函数着色器来说，我们需要完全使用ShaderLab的语法（即使用ShaderLab的渲染设置命令）来编写，而非使用Cg/HLSL 由于现在绝大多数GPU都支持可编程的渲染管线，这种固定管线的编程方式已经逐渐被抛弃 实际上，在Unity5.2中，所有固定函数着色器都会在背后被Unity编译成对应的顶点/片元着色器，因此真正意义上的固定函数着色器已经不存在了 3.4.4 选择哪种Unity Shader形式 除非你有非常明确的需求必须要使用固定函数着色器，例如需要在非常旧的设备上运行你的游戏（这些设备非常少见），否则请使用可编程管线的着色器，即表面着色器或顶点/片元着色器 如果你想和各种光源打交道，你可能更喜欢使用表面着色器，但需要小心它在移动平台的性能表现 如果你需要使用的光照数目非常少，例如只有一个平行光，那么使用顶点/片元着色器是一个更好的选择 最重要的是，如果你有很多自定义的渲染效果，那么请选择顶点/片元着色器 3.5 本书使用的Unity Shader形式 本书的目的不仅在于教给读者如何使用Unity Shader，更重要的是想要让读者掌握渲染背后的原理，仅仅了解高层抽象虽然可能会暂时使工作简化，但从长久来看”知其然而不知其所以然”所带来的影响更加深远 因此，在本书接下来的内容中，将着重使用顶点/片元着色器来进行Unity Shader的编写 3.6 答疑解惑3.6.1 Unity Shader != 真正的Shader Unity Shader并不等同于第2章中所讲的Shader，尽管Unity Shader翻译过来就是Unity着色器。在Unity里，Unity Shader实际上指的就是一个ShaderLab文件——硬盘上以shader作为文件后缀的一种文件 在传统的Shader中，我们仅可以编写特定类型的Shader，例如顶点着色器、片元着色器等。而在Unity Shader中，我们可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码 在传统的Shader中，我们无法设置一些渲染设置，例如是否开启混合、深度测试等，这些是开发者在另外的代码中自行设置的。而在Unity Shader中，我们通过一行特定的指令就可以完成这些设置 在传统的Shader中，我们需要编写冗长的代码来设置着色器的输入和输出，要小心地处理这些输入输出的位置和对应关系等。而在Unity Shader中，我们只需要在特定语句块中声明一些属性，就可以依靠材质来方便地改变这些属性。而且对于模型自带的数据（如顶点位置、纹理坐标、法线等）Unity Shader也提供了直接访问的方法，不需要开发者自行编码来传给着色器 由于Unity Shader的高度封装性，我们可以编写的Shader类型和语法都被限制了。对于一些类型的Shader，例如曲面细分着色器（Tessellation Shader）、几何着色器（Geometry Shader）等，Unity的支持就相对差一些 3.6.2 Unity Shader和CG/HLSL之间的关系 正如之前所讲，Unity Shader是用ShaderLab语言编写的，但对于表面着色器和顶点/片元着色器，我们可以在ShaderLab内部嵌套Cg/HLSL语言来编写这些着色器代码 这些Cg/HLSL代码是嵌套在CGPROGRAM和ENDCG之间的，如下图所示： 从本质上来说Unity中只存在顶点/片元着色器 "},{"title":"Unity Shader入门精要 第一、二章","date":"2022-08-08T04:57:32.000Z","url":"/2022/08/08/Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","tags":[["shader","/tags/shader/"],["unity","/tags/unity/"]],"categories":[["学习记录","/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"]],"content":"1.1 Shader是什么 shader就是着色器 2.1 渲染流水线(概念上)渲染流水线的工作任务在于由一个三维场景出发，生成(渲染)一张二维图像。一般分为三个阶段： 应用阶段：输出渲染图元(点、线、三角面等) 开发者任务： 准备好场景数据(摄像机位置、视锥体、场景中包含的模型、光源)； 做一个粗粒度剔除工作，把不可见的物体剔除，不交给几何阶段处理； 设置好每个模型的渲染状态(材质、纹理、shader)。 几何阶段：输出屏幕的顶点信息 开发者任务： 1.处理所有和我们要绘制的几何相关的事物(决定需要绘制的图元是什么、怎样绘制它们、在哪里绘制) 光栅化阶段：使用上一阶段的数据来阐述屏幕上的像素。并渲染出最终的图像 2.2 CPU和GPU之间的通信2.2.1 把数据加载到显存中 从硬盘加载到内存 然后网格和纹理等数据又被加载到显卡上的存储空间–显存 2.2.2 设置渲染状态 定义场景中的网格是怎样被渲染的 2.2.3 调用Draw Call 是一个命令，发起方是CPU，接收方是GPU，仅仅指向一个需要被渲染的图元列表，不会包含任何材质信息 2.3 GPU流水线2.3.1 概述 几何阶段和光栅化阶段可以分成若干个更小的流水线阶段，这些流水线阶段由GPU来实现，每个阶段GPU提供了不同的可配置性和可编程性 顶点数据：输入 顶点着色器：实现顶点的空间变换、顶点着色等功能 曲面细分着色器：用于细分图元 几何着色器：用于执行逐图元的着色操作，或用于产生更多图元 裁剪：将不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片 屏幕映射：负责把每个图元的坐标转换到屏幕坐标系中 三角形设置：固定函数阶段 三角形遍历：固定函数阶段 片元着色器：实现逐片元的着色操作 逐片元操作：修改颜色、深度缓冲、进行混合等 屏幕图像 2.3.2 顶点着色器（几何阶段） 输入进来的每个顶点都会调用一次顶点着色器 工作：坐标变换、逐顶点光照 把顶点坐标从模型空间转换到齐次裁剪空间（如(5,10,8)-&gt;(.6,.4,.2) 0-1之间） 2.3.3 裁剪（几何阶段） 不处理不在相机范围内的物体 三种关系： 完全在视野内 – 将图元传递给下一流水线 部分在视野内 – 在视野交界处用新的顶点代替 完全在视野外 – 不会传递图元 2.3.4 屏幕映射（几何阶段） 把每个图元的x和y坐标转换到屏幕坐标系下 屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系 2.3.5 三角形设置（光栅化阶段） 计算光栅化一个三角网格所需的信息 2.3.6 三角形遍历（光栅化阶段） 检查每个像素是否被一个三角网格所覆盖 是的话就生成一个片元 2.3.7 片元着色器（光栅化阶段） 也被称为像素着色器 将上一个片元数据处理为颜色值 2.3.8 逐片元操作（光栅化阶段） 也被称为输出合并阶段 1.决定每个片元的可见性：· 模板测试：将模板缓冲区中该片元的值和参考值进行比较；限制渲染区域· 深度测试：将该片元的深度值和已经存在于缓冲区中的深度值进行比较 2.混合颜色——混合：· 关闭-就会直接覆盖· 开启：就会对片元颜色和缓冲区颜色进行混合 双重缓冲：交换后置缓冲和前置缓冲的内容；后置缓冲进行光栅化；前置缓冲进行显示 2.4 一些容易困惑的地方2.4.1 什么是OpenGL/DirectX 显卡驱动把OpenGL和DX的函数调用翻译成GPU执行命令 应用程序通过调用OpenGL和DX的图形接口将渲染所需的数据，如顶点数据、纹理数据、材质参数等数据存储在显存的特定区域 2.4.2 什么是HLSL、GLSL、CG HLSL：· DX的着色语言，着色语言是专门用来编写着色器的· 微软的 GLSL：· OpenGL的着色语言· 跨平台 CG：· 英伟达的C for graphic· 跨平台 2.4.3 什么是Draw Call CPU调用图像编程接口，以命令GPU进行渲染的操作 通过命令缓冲区来并行工作 Draw Call多了会影响帧率 使用批处理可以有效较少Draw Call数量（类比多个小文件打成压缩包复制到别处会快很多） 2.4.3 什么是固定管线渲染 只提供配置操作 没有对流水线阶段的完全控制权 2.5 那么，你明白什么是Shader了吗 GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码会在GPU上运行 有一些特定类别的着色器，比如顶点着色器、片元着色器 依靠着着色器，我们可以控制流水线中的渲染细节，例如用顶点着色器进行顶点变换以及传递数据，用片元着色器来逐像素的渲染 操作包括：设置适当的渲染状态，使用合适的混合函数，开启还是关闭深度测试/深度写入 "},{"title":"从零搭建V2Ray翻墙服务器及维护事项","date":"2022-03-16T13:53:41.000Z","url":"/2022/03/16/vpn-create/","tags":[["v2ray","/tags/v2ray/"]],"categories":[["教程文档","/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"content":"前言 这是一条个人在网上搜集资料总结的blog 已按步骤顺序排列~ 月费5＄左右（一直不关服务器的情况下） 教程中使用的案例服务器已经删除，因此IP地址等基本未打码 - 第一步、VPS VPS介绍 虚拟专用服务器（Virtual Private Server，简称VPS）技术，是将一台服务器分割成多个虚拟专享服务器的优质服务。实现VPS的技术分为容器技术，和虚拟化技术。在容器或虚拟机中，每个VPS都可选配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为使用者提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。 这里以Vultr为例，前往Vultr首页 -&gt; 注册一个账号系统会寄一封验证邮件，激活它 Products -&gt; 右侧加号选择服务器 选择Cloud Compute CPU &amp; Storage Technology选便宜的Regular Performance就行 （后来出的选项，做教程时才发现的） Server Location 用过日本、洛杉矶、New Jersey(新泽西州)的伺服器，体验还不错，其他地区可自行测试 伺服器类型选CentOS 7x64 Server Size选最便宜的可获得每月2TB的流量，当然这个无所谓，因为用不完，就算用完了可以重新搭建，流量会清零，所以不用管 Add Auto Backups关掉，因为收费也是后来出的功能，咱也不造有啥用qwq 其他选项默认就行，然后点击右下角 Deploy Now 等待创建完成 完成后进入界面，注意IP Address、Username、Password一会要用到 用cmd先ping以下该IP地址，若ping得通、延迟较小则可下一步若ping不通或者丢包率高，则点击加号重复创建步骤 注意:ping不通时先创建，得到满意的服务器后，再Destory掉不要的服务器否则你创建的IP还会是你Destory前的IP - 第二步、安装V2Ray 什么是V2Ray 你可以把V2Ray理解成为一套专有的工具，它可以帮助你在互联网上建立属于自己的私有网络，以实现受保护的通信，避免信息遭受恶意窃取或攻击。V2Ray属于一个大的技术项目，名为Project V。V2Ray主要负责处理网络协议和通信，它可以独立使用，也可与其他工具组合使用。从安装和使用的角度看，V2Ray分为服务器端、客户端，需要分别安装在不同的设备之上。 通过上图Server Information页面中右上角进入控制台(View Console)或下载Xshell连接终端机 由于View Console中不显示中文，这里将演示Xshell中的操作方法 新建会话 复制IP地址到名称，软件将自动填写主机，当然名称可以取别的 左侧选择用户身份验证复制进去账号密码 -&gt; 确定 进入会话，弹出SSH安全警告时选择接受并保存 接下来依次输入以下指令安装V2Ray 注意Xshell中的复制粘贴不是Ctrl + C/V 安装时一直回车，保持默认就行，接下来会讲解有用的部分 安装完后是这样的： 需要注意的有：IP、端口、ID、传输协议类型 这里推荐将传输协议改成kcp （因为前段时间换端口tcp会秒被墙，好像叫tcp阻断来着） 输入 ： 输入： “ 2 “ - “ 2 “ - “ 6 “ 改为kcp协议 接着开放udp和tcp端口 输入： 其中port=后面的数字为你的端口号 最后重启防火墙 到此V2Ray已经配置完成 接下来是V2Ray配置补充内容(可跳过)： 作用为可能能加速网络 方法一:输入v2ray -&gt; 11.其他 -&gt; 1.安装BBR -&gt; 按照提示下一步到底就行 方法二:分别输入以下指令： ./tcp.sh 为脚本菜单，4、5、6、7、8加速方法可自行体验 - 第三步、V2Ray客户端 Windows：下载安装带V2Ray-Core的V2RayN 官方网站 安卓：下载V2RayN IOS：使用外区账号下载Shadowrocket（下载付费），无账号或支付途径可走tb使用Sideloadly自签没成功过，也没研究，感兴趣可以试试 服务器 - 添加[VMess]服务器 复制进地址、端口号、用户ID、传输协议改为kcp - 确定 这样你的客户端就配好了 常用快捷键：Ctrl+P 、 Ctrl+T 使用时在右下角任务栏里选择代理方式和服务器 一般只用到全局模式和PAC模式 可批量导出配置给别的设备上配置使用 - 第四步、维护 当你在使用梯子时，突然连接不上了，这时该怎么办；首先检查是否Ping得通IP地址，若Ping不通，重新搭建服务器；若能Ping通，修改端口号，开放对应的tcp、udp端口，重启防火墙，修改客户端配置即可 至此，教程结束，感谢观看！"},{"title":"Hello World And My First Blog","date":"2022-03-16T06:31:54.000Z","url":"/2022/03/16/my-first-blog/","categories":[["undefined",""]],"content":"第一章内容 第二章test参考test Welcome to Hexo! This is your very first post. Check documentation for more info. Quick StartCreate a new post Run server Generate static files Deploy to remote sites testtesttesttest"},{"title":"Kratos-Rebirth食用说明","date":"2020-04-07T07:27:05.000Z","url":"/2020/04/07/Kratos-Rebirth-Manual/","categories":[["教程文档","/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"content":"没错这是一个文档！（被打死 安装提示由于本模板使用了和默认模板landscape一样的ejs引擎，因此当您完成Hexo站点的安装后，您应该能够直接运行本主题。 在运行之前，请您将_config.yml.example文件复制一份，并重命名为_config.yml； 主题配置配置文件地址：./kratos-rebirth/_config.yml - Global 全局配置 site_analytics : 站点统计代码，这一行代码会被插入到后页脚。 hoster : 网站托管服务提供者，这个是出于感恩性的可选添加内容，这一个链接会被插入到后页脚。 site_logo : 网站的LOGO图片文件，请注意与后面核心JS的设置保持一致。 snow : (true/false)站点下雪特效开关，控制是否在载入下雪相关的代码。 click_animate_js : (filename/false) 点击事件使用的动画 js 文件，默认为 candy 即主题自带的 candy.js 文件，您可以设置成 false 表示禁用，或是引入其他您喜欢的动画 js 文件。 enable_dark : (true/false)站点是否启用暗色模式适配。请注意，即使启用了暗色模式，在亮色的环境下主题仍然会渲染为亮色模式；同时用户可以手动选择使用的颜色（右下角菜单栏按钮处）。 highlight_theme : 代码高亮主题，五选一（light | night | night-eighties | night-blue | night-bright），控制代码高亮时候使用的配色。会根据用户的选择自动加载对应的高亮主题文件。 cdn (jsdelivr/unpkg/false)为静态资源开启CDN加速（使用jsDelivr或是unpkg，如果开启则默认使用jsdelivr，有其他什么好建议可以随时提出issue）。请注意，如果您修改了任何静态资源，那么请保持此项为false（同时也是默认状态） check_update (true/false)版本更新检查，无需检查的话就记得关闭哦。 - Custom Styles 自定义样式这部分配置的内容可以覆盖 CSS 文件中指定的部分。 images 图片 banner 站点横幅 background 站点背景 - Index 首页配置相关 post_type (true/false)站点首页是否使用文章主题的显示模式（即一开始可见一部分，点击阅读更多可以加载全文，Hexo许多主题都默认的显示模式（而不是默认的这种卡片式的陈列方式） read_count (true/false)在首页显示每篇文章的阅读量统计（目前仅支持 valine/waline 评论系统的内置统计功能） comment_count (true/false)在首页显示每篇文章的评论量统计（目前仅支持 waline 评论系统的内置统计功能） - Top Menu 顶部导航栏相关 分为menu和label两个模块，控制页首的顶部导航栏内容。menu模块提供导航到的页面位置，label模块提供导航选项卡的显示内容。请注意menu项与label项需要一一对应，否则可能会出现无法正常显示的情况。配置样例随主题附带，可以参考使用。 现已加入二级菜单支持，配置格式为： 请注意关键词submenu不可被改变，其他内容在保证一一对应的情况下可以自定义。具体可以参照主题自带的样例配置。 额外提示：二级菜单功能可能会和旧版本的部分函数发生冲突，如果出现意外报错的话可以考虑检查一下是否存在更新的Hexo版本，或者去Github提一个Issue。目前开发使用的环境(package.json文件)可以参见🎁 使用环境小贴士 - Footer 页脚显示相关 group_link : 控制是否在页面右下角显示群聊的加入按钮。如果显示的话，这里可以指定加群的链接。无需显示的话请留空（而不是删除这个设置项），相关的代码会自行处理结构生成关系。 contact : 联系方式相关，控制是否在页脚(./kratos-rebirth/layout/_partial/footer.ejs)显示各种联系方式的按钮如果要启用的话，请输入相关联系方式的代码，直接输入用户名即可（fediverse的实例需要输入实例地址，邮箱请使用&#x6d;&#97;&#105;&#108;&#64;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;这样的格式）；无需显示的内容请留空。 timenotice : 本站运行时间前的提示文本。 icp : ICP备案号，便于生成快捷链接，如萌ICP备22010101号 psr : 公安备案号，便于生成快捷链接，如371402000001 - Post Page 文章页面相关 show_cc : (true/false)控制文章页面(./kratos-rebirth/layout/post.ejs)是否显示CreativeCommon知识共享协议相关的提示内容w donate : (true/false)控制文章页面是否显示捐助的二维码按钮，二维码链接可以在站点的 JavaScript 相关的配置 里进行修改（详见下文） share : (true/false)控制文章页面是否显示分享链接的按钮 comments : (disqus/disqusjs/valine/twikoo/waline/gitalk/gitment/false)会从layout/_comments文件夹中加载指定的评论系统，您也可以自定义其他的解决方案。如果不想开启评论的话，那就还是设置为false吧~ - Disqus 评论相关 shortname : 站点短代号，需与 Disqus Admin - Settings - General - Shortname 的保持一致 - DisqusJS 评论相关这里使用了DisqusJS这个项目，具体的参数配置相关的可以参考原始文档，这里提供的说明仅供参考w shortname : 站点短代号，需与 Disqus Admin - Settings - General - Shortname 的保持一致 sitename : 站点名，建议与 Disqus Admin - Settings - General - Website Name 的保持一致 api : API服务器地址，官方有提供一个反向代理地址，也可以使用其他的API代理服务，或是自建相关的代理，如本站使用自建的代理() apikey : DisqusJS发起请求时使用的公钥，本主题目前只考虑了一个的情况，如果有多请求需求的话可以考虑直接修改./kratos-rebirth/layout/_comments/disqusjs.ejs的代码 admin : 站点评论区管理员的Disqus用户名，可以在 Disqus - Settings - Account - Username 获取或进行修改 adminlabel : 站点管理员的提示标签，可以在 Disqus Admin - Settings - Community - Moderator Badge Text 获取或进行修改 - Valine 评论相关这里使用了Valine这个项目，具体的参数配置相关的可以参考原始文档，这里提供的说明仅供参考；如果您有自定义功能的需要，您可以考虑手动修改layout/_comments/valine.ejs文件中相关的配置内容。 app_id : 您LeanCloud的APP ID app_key : 您LeanCloud的APP Key visitor : (true/false)是否开启Valine的阅读统计功能 enableQQ : (true/false)是否开启昵称框自动获取QQ昵称和QQ头像 - twikoo评论相关 env_id : 您twikoo的Env ID - Waline 评论相关这里使用了Waline这个项目，具体的参数配置相关的可以参考Waline文档的前端配置段，自行调整相关前后端的配置。在该配置段下的内容都会被自动引入至评论模块中。el 和 path 会在页面自动生成，不必加入。 - Gitalk 评论相关这里使用了Gitalk这个项目，具体的参数配置相关的可以参考Gitalk 文档，自行调整相关前后端的配置。在该配置段下的内容都会被自动引入至评论模块中。id 会在页面自动生成，不必加入。 - APlayer 音乐播放器相关（页面左下角） enabled : (true/false)用音乐来点缀全新的体验吧！这里可以选择是否开启aplayer播放器哦~ playlist : APlayer播放使用的歌单地址，可以使用公开的API服务，或是搭建自己使用的后端。我提供了一个后端API的样例，目前本站点使用的就是这个，可以去Github获取。不过这个项目已经过时，我们推荐使用下一种加载方式，即使用MetingJS（默认使用api.i-meto.com/meting/api解析）的方式来加载。 meting : 使用MetingJS时请保留该选项 server : 使用的音乐服务来源：netease, tencent, kugou, xiami, baidu type : 加载的播放列表类型：song, playlist, album, search, artist id : 请求的ID，如曲目ID、播放列表ID、专辑ID、搜索关键词等 order : (list/random)音乐播放的顺序，我个人比较喜欢的是random模式，这样就能避免每次访问博客时，都是从第一首音乐开始播放的尴尬清情况。 - Widgets 侧边栏与挂件 sidebar : (left/right/none)是否启用侧边栏与小工具，若设置为left则会显示在页面左侧，若设置为right则会显示在页面右侧。 widgets : 启用的小部件，默认全部启用，不喜欢的就删掉吧 请注意splitter是分隔符，用于分割活动区域和固定区域（例如默认配置下文章页向下滚动时，About区块会顺势上浮，toc区块会固定在最顶，您可以手动调整各小挂件的位置，删除splitter表示禁用该功能（即所有小挂件均固定显示） avatarUri : 头像的图片地址链接 mobile_toc : 移动端文章目录显示相关配置 hide : (true/false)是否隐藏移动端目录 hide_id : (true/false)移动端目录前是否自动补充的标号 - FancyBox 图片放大显示 fancybox : (true/false)启用图片放大显示工具，点击文章内的图片可以进行全屏放大操作 - Search 搜索 enable : (true/false)是否启用站点搜索功能 path : 搜索数据库的文件名，一般保持默认search.json即可 field : 搜索的区域，可以是页面，或是文章，或是所有内容。默认情况下是仅搜索文章内容。 content : (true/false)搜索内容是否包含文章或是页面的详细内容 - JavaScript 相关的配置 main : 主JavaScript配置 pic : 无图片文章使用的随机图片相关设置 CDN : (jsdelivr/unpkg/false)图片是否使用CDN来载入（如果有本地替换过图片，请设置为 false 以避免图片失效） random_amount : 表示图片的编号为 1 ~ 您设定的值，默认是 20 filename : 图片的文件名格式 createTime 站点建立的时间，请改成您站点建立的时间。该项与页脚的运行时间有直接关联，建议按照样例格式进行书写，以免出现莫名其妙的报错。 donateBtn 捐助按钮上显示的文字，建议不要太长以免溢出，如果不显示捐助按钮的话就不用去管它啦~ kr.scanNotice 二维码小窗口上的小标题，如果不显示捐助按钮的话也不用去管它啦~ qr_alipay 支付宝二维码的文件地址 qr_wechat 微信支付二维码的文件地址 siteLeaveEvent (true/false)是否启用站点失焦事件（只是为了卖萌，有可能会影响到历史记录，请谨慎开启） leaveTitle 离开时候站点标题的追加内容 returnTitle 返回时候站点标题的追加内容 expire_day 文章过期提示：距离最后更新时间多少天时，打开文件会给出提示信息 topNavScrollToggle (true/false)顶部导航栏在页面向下滚动时隐藏 - Site verify related 站点所有权验证相关 site_verify : google : Google Search，只填写中间那一串随机码即可 baidu : 百毒搜索，同样只需填写中间的一串随机码 bing : 必应搜索，同样只需填写中间的一串随机码 - Friends page related 友链页面相关 工作模式 我们提供两种配置友链的方式： 一种是自动生成单独的页面，您只需要指定页面的路径（href配置内容）即可自动生成 另一种则是Tag工作模式（href项留空或删除），主题会生成一个方便您使用的小标签，在任何一个页面或是文章内插入{% friends %}即可自动生成友链块。 friends : 友链页面全局字段，删除此字段以禁止自动生成友链页面 href : 友链页面的路径，如friends表示yoursite.ltd/friends/的路径，留空此字段会使用Tag模式 page : 页面相关的参数，您可以配置任意多您需要的页面参数，提供的样例可供您参考 list : 友链列表，您可以参照提供的样例进行对应的复制修改，每一项可以提供显示的名字(name)、简介(bio)、头像链接(avatar)和目标站点链接(link)，无用项建议留空（而不是直接删除） verify : 是否在每次启动时验证友联的可访问性 文章页面配置路径：顶部，文章信息区 (Front-Matter) pic : 可以指定这篇文章是否使用自定义的缩略图名称（在文章资源文件夹内），而不是使用随机化的图标 sticky : (number)重要的文章，把它们置顶吧！数字越大优先级越高哦~ comments : (true/false)是否为单篇文章指定开启或关闭评论区 toc： (true/false)该文章是否需要生成目录 only： 指定文章显示的位置，有以下关键词： home: 在首页显示 category: 在分类页显示 tag: 在标签页显示 留空或是不配置此项，则文章在所有该出现的位置都会显示。层级之间相互平等，没有覆盖关系。特别地，如果配置了此项，但是使用的并不是以上的关键词（例如只留了一个- none，那么文章就被隐藏起来了） 一个完整的 Front-Matter 区样式如下（可自行删去不必要的内容）： 模板与特定页面项目Kratos-Rebirth-Specified-Pages已经废弃，所有功能均已内置，无需使用额外的模块。 此处给出我使用的scaffolds/post.md文件内容： 模板特有标签组件提示信息喵呼呼o(=•ェ•=)m 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠内容 这是一条折叠内容 这是一条预先展开的折叠内容 提示面板 这是一个提示面板框 TYPE是面板框的类型，可以是： success danger info warning 模糊字符这里有一些被模糊的字符 关于MathJax对公式进行的处理功能已废弃，建议使用类似hexo-math类似功能的插件，相关的代码注入部分已经修复。 关于Hexo书写的小技巧Hexo使用了MarkDown，但是在一些细节的处理上有很棒的技巧哦~ 文章概要可以将文章开头的一段作为概要显示在首页主题部分，方法就是在需要分割的地方加入&lt;!-- more --&gt;即可；或者可以在文章头指定excerpt 图片资源Hexo有为每篇文章生成一个资源文件夹，可以将图片资源以{% asset_img 文件名 备注 %}的格式插入文章，本主题引入的fancybox会自动实现对文章内图片的放大功能。 "}]